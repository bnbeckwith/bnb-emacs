* Installation

  My =init.el= file is quite simple and is generated by the following
  block.  Essentially, I just have to install this package
  (=bnb-emacs=) in the =~/.emacs.d/= directory and run the code block
  to bootstrap the system.

#+BEGIN_SRC emacs-lisp :tangle "../init.el" :exports code :results silent
  (require 'package)
  (package-initialize)

  (require 'ob-tangle)
  (org-babel-load-file "~/.emacs.d/bnb-emacs/Readme.org")
#+END_SRC

* Start Timer

   I use a timer to see how long it took my setup to load.  At the
   end, I will check this timer and report on a the length of time to
   load.

#+BEGIN_SRC emacs-lisp
  (defvar *emacs-load-start* (current-time))
#+END_SRC

* Personal Information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Benjamin Beckwith")
#+END_SRC

* Style

** Frame Changes

    These following items make Emacs really beautiful on every
    platform.  I remove the menu bar, tool bar and the scroll bar for
    starters.  Then, I setup the fringe area with some items

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

** Window Changes

#+BEGIN_SRC emacs-lisp
  (setq indicate-buffer-boundaries 'right)
  (setq indicate-empty-lines t)

  (setq frame-title-format '("%b - %F"))
#+END_SRC

** Org Fonts

    This face needs to be set to strike-through to look great.

#+BEGIN_SRC elisp :export none
  (eval-after-load 'org-mode
   (set-face-attribute 'org-done nil :strike-through t))
#+END_SRC

** Perspective Fonts

    I set this face through customize.

#+BEGIN_SRC elisp :export none
  (eval-after-load 'perspective
    (set-face-attribute 'persp-selected-face nil :foreground "SystemActiveTitle" :weight 'bold))
#+END_SRC

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (if (file-exists-p custom-file)
      (load-file custom-file))
#+END_SRC

* Small Settings
** Super keys

#+BEGIN_SRC emacs-lisp
;;  (setq w32-pass-lwindow-to-system nil)
  (setq w32-lwindow-modifier 'super)
#+END_SRC

** Package archives

    I like to pull from the popular list of package archives.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("sr" . "http://joseito.republika.pl/sunrise-commander/") t)
#+END_SRC

    After these are set, I can make sure that the proper packages are
    installed.  This may take some time the first time it runs.

#+BEGIN_SRC emacs-lisp
  ;; Idea lifted from prelude https://github.com/bbatsov/prelude
  (require 'cl)
  (defvar bnb/packages
    '(ace-window
      airplay
      bind-key
      bookmark+
      cider
      clojure-mode
      color-theme-sanityinc-tomorrow
      dired+
      edit-server
      guide-key
      htmlize
      highline
      ido-ubiquitous
      keywiz
      magit
      org-plus-contrib
      paredit
      perspective
      powerline
      rainbow-mode
      smart-tabs-mode
      smex
      sunrise-commander
      undo-tree
      writegood-mode))

  (defun bnb/packages-installed-p ()
    (loop for p in bnb/packages
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))

  (unless (bnb/packages-installed-p)
    ;; Need to update package contents
    (message "%s" "Emacs refreshing package contents...")
    (package-refresh-contents)
    (message "done.")

    ;; install the missing packages
    (dolist (p bnb/packages)
      (when (not (package-installed-p p))
        (package-install p))))
#+END_SRC

** Required packages
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'cl))
  (require 'saveplace)
  (require 'ffap)
  (require 'uniquify)
  (require 'ansi-color)
  (require 'recentf)
#+END_SRC
** Binding Keys

   For binding keys, I use the =bind-key= package. Not only does it
   easily bind keys, but it does so with some nice features.

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
#+END_SRC


   By using =bind-key=, you can specify the keystrokes that invoke a
   command. This is regular behavior that you can already achieve in
   Emacs and will result in a global binding.

   If you also want to override any possible minor-mode bindings of
   the same keys, you can use =bind-key*= instead.

   There is also an =unbind-key= to, of course, remove any binding.

   The real kicker is that it will keep track of these bindings and
   let you see a summary of your customizations with

: M-x describe-personal-keybindings

** Minibuffer History Save

    This saves the minibuffer histories to preserve across emacs
    sessions.

#+BEGIN_SRC emacs-lisp
  (setq savehist-additional-variables
        '(search-ring regexp-search-ring)
        savehist-file "~/.emacs.d/savehist")
  (savehist-mode t)
#+END_SRC

** Display times

#+BEGIN_SRC emacs-lisp
  (setq display-time-world-list
        '(("EST5EDT" "Hudson")
          ("CST6CST" "Iowa")
          ("MST7MST" "Fort Collins")
          ("PST8PDT" "DuPont")))
#+END_SRC

** Hippie Expand

    Try to expand the text before point in an intelligent way. Repeat
    the keypress to cycle through options.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-/" 'hippie-expand)
#+END_SRC

** Emacs Bookmarks

    [[http://emacswiki.org/emacs/BookMarks]]

    | Keystroke           | Action                  |
    |---------------------+-------------------------|
    | C-x r m             | Set a bookmark          |
    | C-x r b             | Jump to a bookmark      |
    | C-x r l             | List your bookmarks     |
    | M-x bookmark-delete | Delete bookmark by name |

    I will auto-save my bookmarks.

#+BEGIN_SRC emacs-lisp
  (setq bookmark-save-flag t)
#+END_SRC

** Writegood Mode

    This mode is installed and managed through the ELPA system.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c g" 'writegood-mode)
  (bind-key "C-c C-g g" 'writegood-grade-level)
  (bind-key "C-c C-g e" 'writegood-reading-ease)
#+END_SRC

** Development

    For any lisp development, the following is nice to have.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

    While developing, documentation is nice to have handy and
    automatic.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'cperl-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'eshell-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** Encryption

#+BEGIN_SRC emacs-lisp
  (require 'epa)
  (epa-file-enable)
#+END_SRC
** Faces
*** Default Fonts

     On windows, I have /Source Code Pro/ installed.  Let's use that
     there.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'windows-nt)
    (set-face-attribute 'default nil :font "Source Code Pro-10"))
#+END_SRC

     Setup a strike-through font for agenda items.  Looks prettier.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-agenda-done nil :strike-through t)

  (defadvice enable-theme (after org-strike-done activate)
    "Setup org-agenda-done faces to have strike-through on"
    (and (message "Running advice")
         (set-face-attribute 'org-agenda-done nil :strike-through t)))
#+END_SRC

*** Dynamic Font sizes

    Changing font sizes in presentations is crucial to have at hand. I
    use the following keybindings. "C--" overrides the negative
    argument function, but that one is also accessible by "M--"

#+BEGIN_SRC emacs-lisp
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)
#+END_SRC


*** Mode Line Style

     I dislike the box around the =mode-line= making it look like a
     button.  This face attribute, =box=, can be turned off get get a
     more flat feel.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'mode-line nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil)
  (set-face-attribute 'mode-line-highlight nil :box nil)
#+END_SRC
** Read-only helpers

    For read-only files, look at them in view mode

#+BEGIN_SRC emacs-lisp
  (require 'view)
  (setq view-read-only t)     ; enter view-mode for read-only files
  (define-key view-mode-map "n" 'next-line)
  (define-key view-mode-map "p" 'previous-line)
  (define-key view-mode-map "j" 'next-line)
  (define-key view-mode-map "k" 'previous-line)
#+END_SRC

** Default File encoding

    By default, I like to have the files be =utf-8= by default. Do
    let me know if I shouldn't do this, will you?

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
  ;; MS Windows clipboard is UTF-16LE
  (when (eq system-type 'windows-nt)
    (set-clipboard-coding-system 'utf-16le-dos))
#+END_SRC

** Vimrc generic mode

    Good to have to help with my pentadactyl configuration as it is in
    a vim-style of configuration.

#+BEGIN_SRC emacs-lisp
  (define-generic-mode 'vimrc-generic-mode
    '()
    '()
    '(("^[\t ]*:?\\(!\\|ab\\|map\\|unmap\\)[^\r\n\"]*\"[^\r\n\"]*\\(\"[^\r\n\"]*\"[^\r\n\"]*\\)*$"
       (0 font-lock-warning-face))
      ("\\(^\\|[\t ]\\)\\(\".*\\)$"
       (2 font-lock-comment-face))
      ("\"\\([^\n\r\"\\]\\|\\.\\)*\""
       (0 font-lock-string-face)))
    '("/vimrc\\'" "\\.vim\\(rc\\)?\\'")
    '((lambda ()
        (modify-syntax-entry ?\" ".")))
    "Generic mode for Vim configuration files.")
#+END_SRC

** Ediff single frame

    I really dislike the multi-frame mode of =ediff=.  It is confusing
    to use and really messes up my [[http://dwm.suckless.org][dwm]] usage. By explicitly setting
    the following setting, it forces =ediff= to use only one
    frame.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

    Now, the control window will be a small window instead of a
    separate frame.

** Magit

    [[info:magit#Top][Magit]] is a git interface for Emacs.

    Here I set a global key for ~magit-status~. Think 'G' looks
    like 6.

#+BEGIN_SRC emacs-lisp
  (bind-key "<f6>" 'magit-status)
#+END_SRC

** Powerline
#+BEGIN_SRC emacs-lisp
  (setq powerline-default-separator 'slant)
  (powerline-default-theme)
#+END_SRC
** Global Keys

*** Edit This file

     When I hit ~<F5>~, open this file for editing.  That way, any
     time I have something I need to remember for my emacs setting, it
     is just a button-push away.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>")
                  (lambda ()
                    (interactive)
                    (find-file "~/.emacs.d/bnb-emacs/Readme.org")))
#+END_SRC

** Sounds

    I dislike the bell ringing when I hit =C-g=. To silence the bell,
    just set the =ring-bell-function= to =nil=.

#+BEGIN_SRC emacs-lisp
  (setq visual-bell nil)
  (setq ring-bell-function `(lambda () nil))
#+END_SRC

** Midnight Mode

    This mode looks at midnight to see if any buffers have been unused
    and kills them. By default, /inactive/ means it hasn't been touched
    for three days.

#+BEGIN_SRC emacs-lisp
  (require 'midnight)
#+END_SRC
** Sunrise Commander

    Sunrise commander is Emacs' answer to the popular Midnight
    Commander. I have a global key below to launch the default
    interface.

#+BEGIN_SRC emacs-lisp
  (bind-key "s-/" 'sunrise)
#+END_SRC

*** Interesting Keys

    | Key    | Purpose                        |
    |--------+--------------------------------|
    | C-cC-s | Switch horizontal/vertical/top |
    | m      | Mark a file for action         |
    | j      | Jump to a different directory  |
    | J      | Move up a directory            |
    | n      | Move cursor to next item       |
    | p      | Move cursor to previous item   |
    | R      | Rename (move) marked file      |
    | q      | Quit                           |
    | v      | Quick view file                |

*** Org Links in Sunrise Commander

   Storing links from Sunrise-commander

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-store-link-functions 'org-diredish-store-link)

  (defun org-diredish-store-link ()
    "Store link to files/directories from dired."
    (when (derived-mode-p 'dired-mode)
      (let ((f (dired-filename-at-point)))
        (setq link (concat "file+system" ":" f)
              desc (concat f " (dired)"))
        (org-add-link-props :link link :description desc)
        link)))

#+END_SRC



** Guide Key

    Provide a guide for long (and easy to forget) key sequences.  The
    prefixes below, such as =C-x r=, have many options that can
    follow.  This mode helpfully shows what options are available in a
    small bottom window.

#+BEGIN_SRC emacs-lisp
  (require 'guide-key)
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x x"))
  (guide-key-mode 1)
  (setq guide-key/recursive-key-sequence-flag t)
  (setq guide-key/popup-window-position 'bottom)
#+END_SRC

** Perspective mode

#+BEGIN_SRC emacs-lisp
  (persp-mode t)
  (defmacro custom-persp (name &rest body)
    `(let ((initialize (not (gethash ,name perspectives-hash)))
           (current-perspective persp-curr))
       (persp-switch ,name)
       (when initialize ,@body)
       (setq persp-last current-perspective)))

  (defun custom-persp-last ()
    (interactive)
    (persp-switch (persp-name persp-last)))

  (define-key persp-mode-map (kbd "C-x x -") 'custom-persp-last)
#+END_SRC

    Now, add some custom perspectives for emacs or orgmode

#+BEGIN_SRC emacs-lisp
  (defun bnb/persp/emacs ()
    (interactive)
    (custom-persp "emacs"
                  (find-file "~/.emacs.d/bnb-emacs/Readme.org")))
  (define-key persp-mode-map (kbd "C-x x e") 'bnb/persp/emacs)

  (defun bnb/persp/org ()
    (interactive)
    (custom-persp "@org"
                  (mapcar 'find-file org-agenda-files)))
  (define-key persp-mode-map (kbd "C-x x o") 'bnb/persp/org)
#+END_SRC

** Ace Window

    Instead of =C-x o= traversal, =ace-window= mode provides numbers
    for quick window access

#+BEGIN_SRC emacs-lisp
  (bind-key "s-s" 'ace-window)
#+END_SRC

** Edit Server

   The edit server is used through chrome to use emacs to edit any
   textareas.  It needs to be started explicitly.

#+BEGIN_SRC emacs-lisp
  (edit-server-start)
#+END_SRC

** Regexp-Builder
   
   Emacs regular expressions are not the easiest to use out of the
   box. Emacs now has [[help:re-builder][regexp-builder]] to assist you in building the
   correct regexp as you type.

   However, to complicate matters, there are five different /syntaxes/
   of regular expression that the builder can use.  The =string=
   syntax is what I tend to use most in searching and replacing, so I
   will make that my default.

#+BEGIN_SRC emacs-lisp
  (setq reb-re-syntax 'string)
#+END_SRC

   | Key Binding | Meaning                                    |
   |-------------+--------------------------------------------|
   | C-c TAB     | Switch syntax                              |
   | C-c C-e     | Sub-expression mode (show matching groups) |
   | C-c C-s/r   | Search forward/backward                    |
   | C-c C-w     | Copy regexp to kill ring                   |
   | C-c C-q     | Quit the builder                           |

   Be sure to consult the [[info:emacs#Regexps][syntax of regular expressions]] to learn more
   about the weird backslashing.

* BNB Helpers

  This is a collection of code specific to how I use emacs.  Some
  are from different websites or other Emacs users.

** Exit behavior

    Instead of exiting emacs, I prefer to leave it running and only
    minimize (iconize) it. Especially since I use =server= with emacs,
    it is advantageous to not kill my session by accident
    (muscle-memory). This idea is from [[http://emacs-fu.blogspot.com/2009/03/windows-and-daemons.html][Emacs-Fu]].

    To accomplish this, I advise the =kill-emacs= function. But first,
    I need to have some pieces in place to perform some functionality
    if a killing operation is triggered (keystrokes, button presses,
    etc).

    I create a variable, =bnb/kill-emacs-hooks=, for functions that
    need to run before emacs is /killed/.

#+BEGIN_SRC emacs-lisp
  (defvar bnb/kill-emacs-hooks)
  (add-hook 'bnb/kill-emacs-hooks
            (lambda () (if (functionp 'server-edit)(server-edit))))
#+END_SRC

    In the hook above, I call the =server-edit= function to act as if
    I am closing emacs for a file opened via the server API. This has
    the effect of providing an illusion of opening the editor on a
    specific file and then closing it with normal keypresses.

    Next, I provide a flag and a function to set the flag if emacs is
    to really exit. We always need an escape hatch.

#+BEGIN_SRC emacs-lisp
  (defvar bnb/really-kill-emacs nil)
  (defun bnb/kill-emacs ()
    (interactive)
    (setq bnb/really-kill-emacs t)
    (kill-emacs))
#+END_SRC

    Now that mechanism is in place, it is time to augment
    =kill-emacs= with some advice around the function.

#+BEGIN_SRC emacs-lisp
  (defadvice kill-emacs (around bnb/pardon-emacs activate)
    "Only kill emacs if a prefix is set"
    (run-hooks 'bnb/kill-emacs-hooks)
    (if bnb/really-kill-emacs
        ad-do-it
      (when (eq system-type 'windows-nt)
        (iconify-frame))))
#+END_SRC

    Now, when any event triggers a call to =kill-emacs=, a small set
    of activities happen. First, the =bnb/kill-emacs-hooks= are run
    performing their jobs. Next, the flag for /really/ exiting is
    checked and then the proper =kill-emacs= is called if
    true. Otherwise, no flag is set and emacs is simply iconified.

** Fullscreen

    To make emacs go fullscreen on windows, a helper program is
    needed. This is found online at bitbucket.

    [[https://bitbucket.org/alexander_manenko/emacs-fullscreen-win32/wiki/Home]]

    I use Alexander's recommended settings.

#+BEGIN_SRC emacs-lisp
  (defun bnb/toggle-full-screen ()
    (interactive)
    (shell-command "C:/Users/bnbeckwi/Documents/Apps/emacs_fullscreen/emacs_fullscreen.exe"))

  (bind-key "<f11> <f11>" 'bnb/toggle-full-screen)
#+END_SRC

** Workweeks

#+BEGIN_SRC emacs-lisp
  (defun bnb/workweek ()
    (interactive)
    (let* ((now (current-time))
           (weeks (string-to-number
                   (format-time-string "%W" now)))
           (days (time-to-day-in-year now))
           (daynum (string-to-number
                    (format-time-string "%w" now)))
           (left (% days 7)))
      (if (and (= 0 daynum) (= left 0))
          weeks
        (+ 1 weeks))))

  (defun bnb/workweek-string ()
    (interactive)
    (concat "WW"
            (number-to-string
             (bnb/workweek))))
#+END_SRC

* Dired

   So, I used =dired+= instead of the regular dired. It offers more
   interesting colors and more flexible ways to mark files.

   For example, to mark by extension, press =*.=, then type the
   extension (with dot).

   The =dired-find-alternate-file= command is disabled by default, so
   I force it to be enabled here. It lets my just type =a= to replace
   the current buffer and reduces the accumulating dired buffers.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'dired+)
    (package-install 'dired+))
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

* Smart Tabs

   [[http://www.emacswiki.org/emacs-en/SmartTabs][SmartTabs]] try to do the right thing regarding tabs/spaces in
   indentation/alignment. It is installed through the package interface. Look for
   =smart-tabs-mode=.

    By default, I'm enabling it in all modes that I can.

    Since we are dealing with tabs here, I also take the time to set
    the default width to 4.  This can be set to something different to get a
    new effect with =smart-tabs-mode= since alignment is handled correctly.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (smart-tabs-insinuate 'c 'javascript 'python 'cperl)
  (setq-default tab-width 4)
#+END_SRC

** Notes

   To retab the whole file, use =C-x h C-M-\=.

* CUA mode

   [[info:emacs#CUA%20Bindings][CUA]] has a primary feature of enabling cut, copy, paste and undo
   shortcuts compatible with many applications (C-x, C-c,
   C-v). However, it also has interesting rectangle features and
   *that* is why I enable it. I also happen to turn off those other
   bindings and prefer the emacs defaults.

#+BEGIN_SRC emacs-lisp
  (cua-mode t)
  (setq cua-enable-cua-keys nil)
#+END_SRC

** Bindings

*** CUA Rectangles

   These take place with an active rectangle. To start/cancel a
   rectangle use =C-RET=.

   | Keys             | Function                                                              |
   |------------------+-----------------------------------------------------------------------|
   | M-<arrow>        | Move rectangle overlay                                                |
   | C-SPACE          | Activate region bounded by rectangle                                  |
   |------------------+-----------------------------------------------------------------------|
   | M-a              | Align all words at the left edge                                      |
   | M-b              | Fill rectangle with blanks (tabs and spaces)                          |
   | M-c              | Closes the rectangle by removing left edge blanks                     |
   | M-f              | Fills the rectangle with a single character (prompt)                  |
   | M-i              | Increases number found on each line of rectangle                      |
   | M-k              | Kills the rectangle as normal multi-line kill                         |
   | M-l              | Downcases the rectangle                                               |
   | M-m              | Copies the rectangle for normal multi-line paste                      |
   | M-n              | Filles each line with increasing numbers (prompt)                     |
   | M-o              | Opens the rect by moving hilighted text right and filling with blanks |
   | M-p              | Toggles virtual straight rectangle edges                              |
   | M-P              | Inserts tabs and spaces to make real straight edges                   |
   | M-q              | Performs text filling on the rectangle                                |
   | M-q              | Performs text filling on the rectangle                                |
   | M-r              | Replaces REGEXP (prompt) by STRING (prompt) in rectangle              |
   | M-R              | Reverse the lines in the rectangle                                    |
   | M-s              | Fills each line of the rectangle with the same STRING (prompt)        |
   | M-t              | Performs text fill of the rectangle with TEXT (prompt)                |
   | M-u              | Upcases the rectangle                                                 |
   | M-<Vertical Bar> | Runs shell command on rectangle                                       |
   | M-'              | Restricts rectangle to lines with CHAR (prompt) at left column        |
   | M-/              | Restricts rectangle to lines matching REGEXP (prompt)                 |
   | C-?              | Shows a brief list of the above commands.                             |
   |------------------+-----------------------------------------------------------------------|
   | M-C-<UP/DOWN>    | Scrolls the lines INSIDE the rectangle up/down                        |

*** CUA Global Mark

     The global mark feature enables a target the receives any
     typed/copied/killed text from any buffer (even the current one).

 | Key           | function                                                                                                            |
 |---------------+---------------------------------------------------------------------------------------------------------------------|
 | <ch>          | All characters (including newlines) you type are inserted at the global mark!                                       |
 | C-x           | If you cut a region or rectangle, it is automatically inserted at the global mark, and the global mark is advanced. |
 | C-c           | If you copy a region or rectangle, it is immediately inserted  at the global mark, and the global mark is advanced. |
 | C-v           | Copies a single character to the global mark.                                                                       |
 | C-d           | Moves (i.e. deletes and inserts) a single character to the global mark.                                             |
 | backspace     | deletes the character before the global mark                                                                        |
 | delete        | deletes the character after the global mark.                                                                        |
 |---------------+---------------------------------------------------------------------------------------------------------------------|
 | S-C-space     | Jumps to and cancels the global mark.                                                                               |
 | C-u S-C-space | Cancels the global mark (stays in current buffer).                                                                  |
 |---------------+---------------------------------------------------------------------------------------------------------------------|
 | TAB           | Indents the current line or rectangle to the column of the global mark.                                             |


* Cider

   Cider will make a nREPL available for Clojure programming. The
   configuaration snippets here are from the
   [[https://github.com/clojure-emacs/cider][project page on github]].

#+BEGIN_SRC emacs-lisp
  ;; Enable eldoc
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)

  ;; Hide special buffers
  (setq nrepl-hide-special-buffers t)

  ;; Stop the error from popping up while working in buffers other than the REPL
  (setq cider-popup-stacktraces nil)

  ;; Stop prompting to save file when killing repl buffer
  (setq cider-prompt-save-file-on-load nil)
#+END_SRC

* IDO (Interactively Do Things)

   I do not believe I could live without this on emacs. Even for just
   finding files, it is awesome.

   First, I start with some basic IDO settings. I enabled it
   everywhere so that it will work in all contexts. I like flex
   matching so I also turn that feature on. Finally,

#+BEGIN_SRC emacs-lisp
  (setq ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (setq ido-create-new-buffer 'always)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ido-file-extensions-order '(".org" ".tex" ".el" ".txt" ".c" ".cpp" ".h" ".clj"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (ido-mode t)
#+END_SRC


** Keystrokes

| Keystroke | Operates on        | Description                            |
|-----------+--------------------+----------------------------------------|
| C-b       | Buffers            | Reverts to the old switch-buffer       |
| C-f       | Files              | Reverts to the old find-file           |
| C-d       | Dirs/Files         | Opens a dired buffer in current dir    |
| C-a       | Files/Buffers      | Toggles showing ignored files          |
| C-c       | Buffers/Dirs/Files | Toggles ignore case for names          |
| TAB       | Buffers/Dirs/Files | Attempt to complete input              |
| C-p       | Files              | Toggles prefix matching                |
| C-s/C-r   | All                | Moves to next/previous match           |
| C-t       | All                | Toggles matching Emacs Regexp          |
| Backspace | All                | Deletes chars or up directory          |
| C-SPC/C-@ | All                | Restricts completion list              |
| //        | Dirs/Files         | Ignore preceding path                  |
| ~/        | Dirs/Files         | Jump to home directory                 |
| M-d       | Files              | Searches for input in cwd sub-dirs     |
| C-k       | Buffers/Files      | Kills focused buffer or deletes file   |
| M-m       | Files              | Creates a new sub-dir to cwd           |
| M-n/M-p   | Dirs/Files         | Cycles through next/previous work dirs |
| M-k       | Dirs/Files         | Kills active work dir from list        |
| M-s M-s   | Dirs/Files         | Search list of work dirs for input     |

* Shells

  There are two useful shells in emacs: =eshell= and
  =ansi-term=.

** Eshell

    Eshell can provide a shell that works the same on windows or
    GNU/Linux. One of the really cool features is that you can define
    commands to use (like aliases) within the shell and have them
    directly integrate with emacs.

#+BEGIN_SRC emacs-lisp
  (defun eshell/emacs (&rest args)
    "Open a file in emacs the natural way"
    (if (null args)
        ;; If emacs is called by itself, then just go to emacs directly
        (bury-buffer)
      ;; If opening multiple files with a directory name, e.g.
      ;; > emacs bar/bar.txt foo.txt
      ;; then the names must be expanded to complete file paths.
      ;; Otherwise, find-file will look in the current directory which
      ;; would fail for 'foo.txt' in the example above.
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
#+END_SRC

* AucTeX

  [[info:AUCTeX][AUCTeX Manual]]

  Superb handling of TeX documents.

** RefTeX

    [[info:RefTeX][RefTeX Manual]]

    RefTeX provides navigation, easy references, easy citations and
    integrates well into AUCTeX.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
#+END_SRC

    | Keystroke | Function                           |
    |-----------+------------------------------------|
    | C-c =     | Show TOC and jump to sections      |
    | C-c (     | Insert a label                     |
    | C-c )     | Reference a label                  |
    | C-c [     | Insert a citation (from BibTex db) |
    | C-c <     | Index entry                        |
    | C-c >     | View index                         |
    | C-c &     | View crossref                      |

** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook 'orgtbl-mode)
#+END_SRC

** TeX Settings

    Here are some nice features to have enabled.  Parse-self and
    auto-save will parse the file on load and save
    respectively. Untabify will remove tabs (real ones) before saving.

    I also have a default of =TeX-master= set to =nil=. I used to have
    it set to "master" as recommended in the documentation, but I had
    bad results for LaTeX files generated on the fly.

#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-untabify t)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
#+END_SRC

    For viewing the output, I can specify the command to use on the
    files generated in the process. However, the programs differ on
    GNU/Linux and Windows, so I have differing settings below.

#+BEGIN_SRC emacs-lisp
  (setq TeX-output-view-style
        (if (eq system-type 'windows-nt)
            (quote
             (("^pdf$" "." "SumatraPDF.exe -reuse-instance %o")
              ("^html?$" "." "start %o")))
        (quote
         (("^pdf$" "." "evince -f %o")
          ("^html?$" "." "start %o")))))
#+END_SRC

** XeTeX settings

    To get more beautiful fonts, I use the XeTeX processor. I also
    use this in PDF mode.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode 1)
  (setq TeX-engine 'xetex)
#+END_SRC

* Orgmode

  The one feature I cannot do without. Let's set up some features.

** Auto mode

    I add gpg and _archive to the list of known org files. These two
    alternative extensions are used for either encrypted org files
    (=.org.gpg=) or for archives (=.org_archive=).

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.org\\(.gpg|_archive\\)?$" . org-mode))
#+END_SRC

** Hooks

    First, I add in a keystroke to toggle the inline images.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
             (lambda ()
               (local-set-key (kbd "M-i") 'org-toggle-inline-images)))
#+END_SRC

    The next hook just saves the org files opened before exiting
    emacs -- just in case.

#+BEGIN_SRC emacs-lisp
  (add-hook 'bnb/kill-emacs-hooks 'org-save-all-org-buffers 'append)
#+END_SRC

** Keys

*** Global

     Some org-mode features are so useful that I need to have them be
     available globally.

     - orgtbl-mode
       Use orgtbl in other modes
     - org-store-link
       Store a link (context-aware) to the current location
     - org-agenda
       Launch the agenda
     - org-capture
       Capture a task/note
     - org-iswitchb
       Switch org buffers
     - visible-mode
       Show the file as-is (no special org handling)
     - org-clock-in/org-clock-out
       Clock in/out of current subtree
     - org-clock-goto
       Go to current/previous clocked task

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c t" 'orgtbl-mode)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cr" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
  (bind-key "<f12>" 'org-agenda)
  (bind-key "<apps>" 'org-agenda)
  (bind-key "<f9> v" 'visible-mode)
  (bind-key "<f9> i" 'org-clock-in)
  (bind-key "<f9> o" 'org-clock-out)
  (bind-key "<f11> i" 'org-clock-in)
  (bind-key "<f11> g" 'org-clock-goto)
#+END_SRC

*** Speed

     Using org-mode efficiently for task management is best done with
     speed keys. This are in effect when the cursor is on the first =*=
     of a headline. And they come with an easy cheat-sheet by typing
     =?=. I enable this feature and add some of my own commands.

#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands t)
  (setq org-speed-commands-user (quote (("0" . delete-window)
                        ("1" . delete-other-windows)
                        ("2" . split-window-vertically)
                        ("3" . split-window-horizontally)
                        ("h" . hide-other)
                        ("R" . org-reveal)
                        ("s" . org-save-all-org-buffers)
                        ("z" . org-add-note)
                        ("N" . org-narrow-to-subtree)
                        ("W" . widen))))
#+END_SRC

** Org TODO Configuration

   This is the meat of what Org can do. Keeping track of todo items
   with due dates, tags, etc. is really powerful. And I get to
   customize it to suit my needs and my workflow.

*** Keywords

      The keywords that org uses in the headlines exist as sequences
      describing the state changes. The characters in =()= also allow
      fast access to these states described [[info:org#Fast%20access%20to%20TODO%20states][here]].

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
            (sequence "WAITING(w@/!)" "SOMEDAY(s!)" "|" "CANCELED(c@/!)")
            (sequence "OPEN(O)" "|" "CLOSED(C)"))))
#+END_SRC

      Also, the keywords can be specifically colored to help the eye
      infer meaning quickly.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keyword-faces (quote (("TODO" :foreground "red" :weight bold)
   ("NEXT" :foreground "blue" :weight bold)
   ("DONE" :foreground "forest green" :weight bold)
   ("WAITING" :foreground "yellow" :weight bold)
   ("SOMEDAY" :foreground "goldenrod" :weight bold)
   ("CANCELED" :foreground "orangered" :weight bold)
   ("OPEN" :foreground "magenta" :weight bold)
   ("CLOSED" :foreground "forest green" :weight bold))))
#+END_SRC

*** Tags

      Org uses tags on headlines for organization. I don't currently
      use them much. I organize mainly by file with a file tag
      specified via [[info:org#In-buffer%20settings][in-buffer settings]] (=#+FILETAGS=).

      However, a global tag list provides a selection list for the
      tagging interface. I use 'project' as my tag to easily
      differentiate simple tasks from more complex ones.

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("PROJECT" . ?p)))
#+END_SRC

*** Mechanics

      The todo interface allows easy selection of states and triggers
      on certain states to store notes.

      Instead of cycling through states (and possibly triggering log
      entries), I prefer fast entry to jump right to the correct
      state. I also turn off the S-cursor transitions as state
      changes to avoid the logging prompts.

#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

      Upon changing the state of todo items, I can automatically
      add/remove tags with the following list. It's a bit lispy, but
      describes what happens upon entry in the specified state. The
      state named as a string has tuples of tags and flags. 't'
      indicates to set the flag, empty means to remove it.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-state-tags-triggers
        (quote (("CANCELED"
                 ("CANCELED" . t))
                ("WAITING"
                 ("WAITING" . t))
                ("SOMEDAY"
                 ("SOMEDAY" . t))
                (done
                 ("WAITING"))
                ("TODO"
                 ("WAITING")
                 ("CANCELED"))
                ("NEXT"
                 ("WAITING"))
                ("DONE"
                 ("WAITING")
                 ("CANCELED")))))
#+END_SRC

      Along with tags and states are priorities. I do not use task
      priorities myself so I turn them off.

#+BEGIN_SRC emacs-lisp
  (setq org-enable-priority-commands nil)
#+END_SRC

**** Logging

      Org allows logging of states. I turn this on to prompt myself
      for reasons behind specific state changes. There is also a
      setting to set a different drawer for clocking and logs.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done (quote note))
  (setq org-log-into-drawer t)
  (setq org-drawers '("PROPERTIES" "LOGBOOK" "CLOCK"))
#+END_SRC

**** Sub-tasks

       Naturally, some tasks are projects composed of smaller
       sub-tasks. Org allows for this as well. I like to enforce the
       dependencies of regular todo items and plain checkbox
       lists. In this way, the overall item cannot change to done
       without the completion of the sub-tasks.

#+BEGIN_SRC emacs-lisp
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-enforce-todo-dependencies t)
#+END_SRC

       Because of the previous enforcement of state, I can also
       automatically infer when a parent state is complete. The
       following code marks the parent complete once the sub-tasks
       are all done.

#+BEGIN_SRC emacs-lisp
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all sub-entries are done, to TODO otherwise."
    (let (org-log-done org-log-states)
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC

** Capture

    [[info:org#Capture][Capturing]] is crucial to a task system and in this vein, org is no
    slouch. The capture templates define what get captures, where it
    goes, and what the user needs to type.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry
       (file "~/Documents/Org/Refile.org")
       "* TODO %?\n  %U\n" :clock-in t :clock-resume t)
      ("r" "todo (Remember location)" entry
       (file "~/Documents/Org/Refile.org")
       "* TODO %?\n  %U\n  %a" :clock-in t :clock-resume t)
      ("n" "Note" entry
       (file "~/Documents/Org/Refile.org")
       "* %?                                                                            :NOTE:\n  %U\n  %a\n  :CLOCK:\n  :END:")
      ("i" "Isabelle Journal" entry (file+datetree "~/Documents/Personal/Org/Isabelle.org")
       "* %?\n\tEntered on %U")
      ("j" "Johannes Journal" entry (file+datetree "~/Documents/Personal/Org/Johannes.org")
       "* %?\n\tEntered on %U")
      ("a" "Andrea Journal" entry (file+datetree "~/Documents/Personal/Org/Andrea.org")
       "* %?\n\tEntered on %U")
      ("e" "Journal" entry (file+datetree "~/Documents/Personal/Org/Journal.org")
       "* %?\n\tEntered on %U")
      ("c" "Capture current TODO mix in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Burndown")
       "%(bnb/org-count-tasks-by-status)")
      ("s" "Capture Weekly Score in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Scores")
       "%(bnb/add-weekly-score-table-entry)")
      ("o" "org-outlook" entry
       (file "~/Documents/Org/Refile.org")
       "* TODO EMAIL: %:title (%:sender)
    %c

    %?" :clock-in t :clock-resume t)))
#+END_SRC

    There are five main capture templates here. The first two store a
    todo item in my Refile.org file. The only difference is automatic
    (contextual) link storage in the second case.

    The next item simply stores a note. The next for "Weekly Report"
    is a work in progress. I think that I'll have to either settle
    for a proper datetree or write a custom function.

    The final item is not for direct use, but through the
    =org-protocol= interface and =org-outlook= usage. This lets me
    add a link to an Outlook message on windows. I can then get an
    email at work, mark it to store in emacs and quickly get back to
    the message later.

*** Capture-template helpers for data tables

     These helpers provide functionality used in the capture templates
     above.

     Modifed from [[http://sachachua.com/blog/2014/05/getting-r-ggplot2-work-emacs-org-mode-babel-blocks-also-tracking-number-todos/][Sacha Chua]], this code get the current mix of tasks
     in the agenda files.  I use this as part of my weekly review for
     task amount and mix at a glance.

#+BEGIN_SRC emacs-lisp
  (defun bnb/org-count-tasks-by-status ()
    (interactive)
    (let ((counts (make-hash-table :test 'equal))
          (today (format-time-string "%Y-%m-%d" (current-time)))
          values output)
      (org-map-entries
       (lambda ()
         (let ((status (elt (org-heading-components) 2)))
           (when status
             (puthash status (1+ (or (gethash status counts) 0)) counts))))
       "-HOME"
       'agenda)
      (setq values (mapcar (lambda (x)
                             (or (gethash x counts) 0))
                           '("DONE" "STARTED" "TODO" "WAITING" "CANCELLED" "SOMEDAY")))
      (setq output
            (concat "| " today " | "
                    (mapconcat 'number-to-string values " | ")
                    " | "
                    (number-to-string (apply '+ values))
                    " | "
                    (number-to-string
                     (round (/ (* 100.0 (car values)) (apply '+ values))))
                    "% |"))
      (if (called-interactively-p 'any)
          (insert output)
        output)))
#+END_SRC

     I also have a helper function to get the score of done tasks
     closed within the last week.  I store this in a table line with
     year and workweek number.

#+BEGIN_SRC emacs-lisp
  (defun bnb/add-weekly-score-table-entry ()
    (let ((score (apply
                   '+
                   (org-map-entries
                    (lambda ()
                      (let* ((status (string-to-number (org-entry-get (point) "Score"))))
                        (or status 0)))
                    "TODO=\"DONE\"+LEVEL<=2+CLOSED>=\"<-1w>\""
                    'agenda)))
           (year (format-time-string "%Y" (current-time)))
           (ww (number-to-string (bnb/workweek))))
      (format "| %s | %s | %s |" year ww score)))
#+END_SRC

** Refile

    [[info:org#Refiling%20notes][Refiling notes]] is also spectacular with Org. That is what makes
    it possible for me to simply put every captured item into
    Refile.org and worry about organization later.

    For my setup, I use separate files that hold a singular Tasks
    headline. Because of that, I turn on caching first.

    For the refile targets, I will allow up to 2 levels of search for
    filing in any of the agenda files. For refiling within the current
    file, I set the max to five levels. Anything deeper than six
    levels will exhaust the depth of my thought.

    Finally, I set the filenames to be first for refiling.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-cache t)
  (setq org-refile-targets '((org-agenda-files :maxlevel . 2)
                             (nil :maxlevel . 5)))
  (setq org-refile-use-outline-path 'file)
#+END_SRC

** Agenda

    Once I have captured and refiled my tasks, I need to remember to
    do them and see what is on the agenda. The ways to view the tasks
    at hand are nicely programmable.

    Some basic settings control small tidbits in the agenda. I turn
    on tags in the agenda line, show the logged items for the day,
    and only show a time grid if a scheduled tasks exists.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-show-inherited-tags t)

  (setq org-agenda-log-mode-items '(clock))

  (setq org-agenda-clockreport-parameter-plist (quote (:link nil :maxlevel 2 :fileskip0 t)))

  (setq org-agenda-time-grid
        (quote ((daily today require-timed)
            "----------------"
            (800 1000 1200 1400 1600 1800 2000))))
#+END_SRC

*** Views

     The key to knowing what work there is the agenda views. These
     provide a landscape to list, filter or manipulate
     tasks. =org-agenda-custom-commands= defines which views are
     available by default.

     First, I define a little helper function (from Sacha Chua) to
     display a note with agenda.

#+BEGIN_SRC emacs-lisp
  (defun bnb/org-agenda-with-tip (arg)
    (org-agenda-list arg)
    (let ((inhibit-read-only t)
          (pos (point)))
      (goto-char (point-max))
      (insert "\n" (bnb/random-keybinding))
      (goto-char pos)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        (quote (("a" "Agenda" bnb/org-agenda-with-tip)
                ("w" "Tasks waiting on something" tags "WAITING/!"
                 ((org-use-tag-inheritance nil)
                  (org-agenda-todo-ignore-scheduled nil)
                  (org-agenda-todo-ignore-deadlines nil)
                  (org-agenda-todo-ignore-with-date nil)
                  (org-agenda-overriding-header "Waiting Tasks")))
                ("r" "Refile New Notes and Tasks" tags "LEVEL=1+REFILE"
                 ((org-agenda-todo-ignore-with-date nil)
                  (org-agenda-todo-ignore-deadlines nil)
                  (org-agenda-todo-ignore-scheduled nil)
                  (org-agenda-overriding-header "Tasks to Refile")))
                ("n" "Next" tags-todo "-WAITING-CANCELED/!NEXT"
                 ((org-agenda-overriding-header "Next Tasks")))
                ("A" "Tasks to be Archived" tags "LEVEL=2-REFILE/DONE|CANCELED"
                 ((org-agenda-overriding-header "Tasks to Archive")))
                ("u" "Upcoming tasks" tags "+SCHEDULED<=\"<+1w>\"-TODO=\"DONE\"|+DEADLINE<=\"<+1w>\"-TODO=\"DONE\""
                 ((org-agenda-overriding-header "Upcoming tasks")))
                ("U" "Unscheduled tasks" todo "TODO"
                 ((org-agenda-overriding-header "Unscheduled Tasks")
                   (org-agenda-skip-function
                   (lambda nil
                     (org-agenda-skip-entry-if (quote scheduled) (quote deadline))))))
                ("P" "Printable Agenda" ;tags-todo "-DONE-CANCELED-SOMEDAY"
                 ((tags-todo "+IGNORE"
                             ((org-agenda-overriding-header "\n== Upcoming Items ==\n")))
                  (agenda "" ((org-agenda-span 14)
                              (org-agenda-start-on-weekday nil)
                              (org-agenda-prefix-format "[ ] %T:\t")
                              (org-agenda-repeating-timestamp-show-all t)
                              (org-deadline-warning-days 7)))
                  (tags-todo "-DRB-SOMEDAY-REFERENCE-BNBECKWITH"
                             ((org-agenda-prefix-format "[ ] %T:\t")
                              (org-agenda-sorting-strategy '(tag-up priority-down))
                              (org-agenda-todo-keyword-format "")
                              (org-agenda-todo-ignore-with-date nil)
                              (org-agenda-todo-ignore-scheduled nil)
                              (org-agenda-todo-ignore-deadlines nil)
                              (org-agenda-overriding-header "\nTasks by Context\n------------------\n"))))
                 ((ps-number-of-columns 2)
                  (ps-landscape-mode t)
                  (org-agenda-with-colors nil)
                  (org-agenda-compact-blocks t)
                  (org-agenda-remove-tags t)
                  (ps-paper-type 'a4))
                 ("~/TODO.pdf" "~/TODO.ps"))
                ("l" "Scoreless" tags-todo "+Score<1"
                 ((org-agenda-todo-ignore-with-date nil)
                  (org-agenda-todo-ignore-scheduled nil)
                  (org-agenda-todo-ignore-deadlines nil)
                  (org-agenda-overriding-header "Scoreless Tasks")))
                ("h" "Habits" tags "STYLE=\"habit\""
                 ((org-agenda-todo-ignore-with-date nil)
                  (org-agenda-todo-ignore-scheduled nil)
                  (org-agenda-todo-ignore-deadlines nil)
                  (org-agenda-overriding-header "Habits")))
                ("#" "Stuck Projects" tags-todo "LEVEL=2-REFILE+PROJECT|LEVEL=1+REFILE/!-DONE-CANCELED"
                 ((org-agenda-skip-function 'bh/skip-non-stuck-projects)
                  (org-agenda-overriding-header "Stuck Projects")))
                ("z" "Agenda (including Personal Files)" agenda ""
                 ((org-agenda-files (list "~/Documents/Personal/Org/"))))
                ("c" "Select default clocking task" tags "LEVEL=2-REFILE"
                 ((org-agenda-skip-function
                   '(org-agenda-skip-subtree-if 'notregexp "^\\*\\* Organization"))
                  (org-agenda-overriding-header "Set default clocking task with C-u C-u I"))))))
#+END_SRC

     Phew! That is a lot of lisp! It is easiest to describe each view
     by the key that triggers it.

     - =a= Agenda with tip (keystroke tip)
     - =w= Tasks waiting on something
     - =r= Refile New notes and tasks
     - =n= Next
       Any task with the NEXT tag
     - =A= Tasks ready for Archive
     - =u= Upcoming tasks
       Scheduled or due in the next week.
     - =U= Unscheduled tasks
     - =P= Printable agenda
       Formats tasks at the top with upcoming items below.
     - =S= Scoreless tasks
       Use this to get the scoreless tasks and edit in column mode
     - =h= Habits
     - =#= Stuck projects
     - =z= Agenda with Personal Files
     - =c= Select default clocking task
** Export

    Some global export settings make sense for HTML and \LaTeX

    For HTML, I just want to inline the links to images.

#+BEGIN_SRC emacs-lisp
  (setq org-export-html-inline-images t)
#+END_SRC

    I also used to suppress the postamble with
    =org-export-html-postamble=.

    For \LaTeX, I want to convert fragments to images, and use minted
    for any source blocks. I also want to have =xelatex= as the
    backend.

#+BEGIN_SRC emacs-lisp
  (setq org-export-latex-listings 'minted)
  (setq org-export-latex-custom-lang-environments
        '((emacs-lisp "common-lispcode")))
  (setq org-export-latex-minted-options '())
  (setq org-latex-to-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC


    Also, I want to enable some of the other contributed
    exporters. To do this, simply require the files necessary that
    are not on by default.

    I add exporters for Markdown (=ox-md.el=) and beamer
    (=ox-beamer.el=).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

** Clocking

    I have found clocking to be useful in understanding where my time
    goes. And Org makes this easy, fast and painless to do. So very
    nice.

    The clock has some general settings around persistence (resuming
    clocks), history length and resuming a task after clocking in
    twice (interrupted task).

#+BEGIN_SRC emacs-lisp
  (org-clock-persistence-insinuate)
  (setq org-clock-history-length 28)
  (setq org-clock-in-resume t)
#+END_SRC

    Behavior of the clock can change to accommodate other needs. I
    like having clocks log into a specific drawer. Also, it is nice
    to remove zero-time clocks and clock out automatically when an
    item completes.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer "CLOCK")
  (setq org-clock-out-remove-zero-time-clocks t)
  (setq org-clock-out-when-done t)
#+END_SRC

    Two settings help resolve most clock issues that I have
    seen. Persisting the clock across sessions helps prevent loss of
    time by accident. Auto-resolution of open clocks help prompt how
    to handle the situation where a dangling clock exists.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-persist 'history)
  (setq org-clock-auto-clock-resolution 'when-no-clock-is-running)
#+END_SRC

    Two final settings regarding clocking setup how I change and view
    the clocks. I want any clock reports to include the currently
    clocked task as well. And for clock editing, I change to 15
    minute increments.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-report-include-clocking-task t)
  (setq org-time-stamp-rounding-minutes '(1 15))
#+END_SRC

** Modules

    Org-modules allow for specific functionality within org-mode.

#+BEGIN_SRC emacs-lisp
  (setq org-modules
        (quote
         (org-bbdb
          org-bibtex
          org-crypt
          org-gnus
          org-id
          org-info
          org-jsinfo
          org-habit
          org-inlinetask
          org-irc
          org-plot
          org-protocol
          org-bookmark
          org-calc)))
#+END_SRC
*** Org-protocol

     For some reason, I have to load =org-protocol= explicitly in
     order to work.

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

*** Crypt

     Encrypts contents of headlines with =gpg= when saved
     with the "crypt" tag.

#+BEGIN_SRC emacs-lisp
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
#+END_SRC

     The =org-crypt-key= variable will let this use an address from
     the public keyring.

*** Habit

     Some tasks repeat, but you still want to log when you have done
     it. I use this to help me always do my weekly or yearly
     reviews. By including it in =org-modules=, habits get activated.

     My one setting blow sets a width for the graph in Agenda View.

#+BEGIN_SRC emacs-lisp
  (setq org-habit-graph-column 50)
#+END_SRC

*** Drill

#+BEGIN_SRC emacs-lisp
  (require 'org-drill)
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (gnuplot . t)
     (clojure . t)
     (ditaa . t)
     (dot . t)
     (latex . t)
     (python . t)
     (perl . t)
     (R . t)
     (C . t)
     (sqlite . t)))

  (when (eq system-type 'windows-nt)
    (setq org-babel-R-command "C:/Progra~1/R/R-2.15.1/bin/R --slave --no-save"))
#+END_SRC

** Miscellaneous Settings
*** Columns

     The default columns are as follows.

#+BEGIN_SRC emacs-lisp
  (setq org-columns-default-format
        "%80ITEM(Task) %5Score{+} %10Effort(Effort){:} %10CLOCKSUM")
#+END_SRC

*** Automatically save org files

    I like to save early and often. In earlier versions of orgmode, I
    sometimes had the capture buffer/timer crash on me. So, now I
    save at the top of every hour to be sure.

#+BEGIN_SRC emacs-lisp
  (run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC

*** File Applications

     This list lets org know how to handle the links of given file
     types. Most things open inside =emacs=, but the others
     set to default rely on the OS to supply a program.

#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        (quote ((auto-mode . emacs)
            ("\\.x?html?\\'" . default)
            ("\\.pdf\\'" . default)
            ("\\.mm\\'" . default))))
#+END_SRC

*** Goto Interface

     By using =C-c C-j=, you can jump easily around a large orgfile
     such as this one. Naturally, the interface you use to do so is
     customizable.

     I explicitly set it to the default because I sometimes go back
     and forth with the default and =outline-path-completion= setting.

#+BEGIN_SRC emacs-lisp
  (setq org-goto-interface 'outline-path)
#+END_SRC

*** Special Control Keys

     Orgmode has a different idea of some of the default emacs
     commands to make it easier to work with the structures involved.

     For =C-a= or =C-e= within a headline, it will only try to
     navigate the headline text the first time. Additional keypresses
     will move to the true beginning/ending of lines.

     =C-k= also can behave specially in headlines depending on its
     location. When point is at the beginning, it will kill the
     headline and the folded subtree below. In the middle of a
     headline, it kills the headline text up to the tags. After the
     headline text, it kills the tags.

#+BEGIN_SRC emacs-lisp
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t)
#+END_SRC

*** Auto-revert mode

     If the org files are under DVCS like git, then the edits may
     happen while open in emacs.

     This is a global setting, but most useful for the org files that
     exists elsewhere.

#+BEGIN_SRC emacs-lisp
  (setq global-auto-revert-mode t)
#+END_SRC

*** IDO Integration

     IDO integrates well into orgmode. Anytime completion is
     necessary, I like to use the IDO mechanics.

     What follows is a few of the smaller settings to make =ido=
     really sing.

#+BEGIN_SRC emacs-lisp
  ; Try to guess if point is at a filename
  (setq ido-use-filename-at-point 'guess)

  ; Do not ask to create a new buffer -- just do it.
  (setq ido-create-new-buffer 'always)
#+END_SRC


     If =outline-path-completion= is used, then it is best to have it
     not complete in steps with IDO mode.

#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

     Additionally, I use the [[https://github.com/technomancy/ido-ubiquitous][ido-ubiquitous]] package to /really/ get
     =ido= everywhere. Install it via the package system and then
     enable it on startup.

#+BEGIN_SRC emacs-lisp
  (ido-ubiquitous t)
#+END_SRC


**** IDO Everywhere Settings

      Here is a setting that disables =ido-ubiquitous= completion from
      any commands listed.  I have =insert-char= here (called with
      =C-x 8 <RET>=) because I like to see the buffer of UTF8 names
      for completion.

#+BEGIN_SRC emacs-lisp
  (setq ido-ubiquitous-command-exceptions '(insert-char execute-extended-command))
#+END_SRC

**** Smex

      [[http://www.emacswiki.org/emacs/Smex][Read more about Smex on the Emacs Wiki]]

      This is built on top of =ido-mode= which is why it is here.
      This provides better =M-x= functionality.

#+BEGIN_SRC emacs-lisp
  (bind-key "M-x" 'smex)
  (bind-key "M-X" 'smex-major-mode-commands)
  (bind-key "C-c C-c M-x" 'execute-extended-command)
#+END_SRC

      One of the nice things about the default command selection (read
      non-ido) is the ability to type " " and have it expand to
      "-". This is possible again with a bit of advice.

#+BEGIN_SRC emacs-lisp
  (defadvice smex (around space-inserts-hyphen activate compile)
    (let ((ido-cannot-complete-command
           `(lambda ()
              (interactive)
              (if (string= " " (this-command-keys))
                  (insert ?-)
                (funcall ,ido-cannot-complete-command)))))
      ad-do-it))
#+END_SRC

*** Display settings

     There are a collection of settings that define how the
     headlines, subtrees, and notes render.

     For the headline stars, there are two settings of note. I am
     explicit that I do *not* want only odd levels. I also like to
     hide the leading stars.

#+BEGIN_SRC emacs-lisp
  (setq org-odd-levels-only nil)
  (setq org-hide-leading-stars nil)
#+END_SRC

     Cycling the headline states can produce different views of the
     files. I like this to be as compact as possible, so I try to
     squash the lines between the collapsed trees. There is also a
     flag to open a file collapsed. This I like too -- I get a
     compact view of the file and can jump to a relevant section with
     =C-c C-j=.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 0)
  (setq org-startup-folded 'content)
#+END_SRC

     When using SRC-blocks, org can provide highlighting native to
     the SRC type. Note that this may slow down some files.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

*** Insertion

     I define when org should leave a blank line before an
     item. In my case, it is headings and plain list items.

#+BEGIN_SRC emacs-lisp
  (setq org-blank-before-new-entry '((heading)
                                     (plain-list-item)))
#+END_SRC

     Also, when inserting a new heading, do so after the current
     subtree.

#+BEGIN_SRC emacs-lisp
  (setq org-insert-heading-respect-content t)
#+END_SRC

*** Properties

#+BEGIN_SRC emacs-lisp
  (setq org-global-properties (quote (("STYLE_ALL" . "habit")
                      ("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00")
                      ("Score_ALL" . "10 5 2 1"))))
#+END_SRC

** Org-drill



* Elisp Extras
** Google

#+BEGIN_SRC emacs-lisp
(defun google ()
  "Google the selected region if any, display a query prompt otherwise."
  (interactive)
  (browse-url
   (concat
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
    (url-hexify-string (if mark-active
         (buffer-substring (region-beginning) (region-end))
       (read-string "Google: "))))))
#+END_SRC

** Keywiz from Sacha Chua

    Taken from
    [[http://sachachua.com/blog/2013/02/rediscovering-emacs-features-or-what-to-do-after-you-get-carried-away-installing-packages/]]

    This gets used in the default agenda view to provide help on
    built-in keybindings.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'keywiz)
    (package-install 'keywiz))
  (require 'keywiz)
  (defun bnb/load-keybindings ()
    "Since we don't want to have to pass through a keywiz game each time..."
    (setq keywiz-cached-commands nil)
    (do-all-symbols (sym)
      (when (and (commandp sym)
                 (not (memq sym '(self-insert-command
                                  digit-argument undefined))))
        (let ((keys (apply 'nconc (mapcar
                                   (lambda (key)
                                     (when (keywiz-key-press-event-p key)
                                       (list key)))
                                   (where-is-internal sym)))))
          (and keys
               (push (list sym keys) keywiz-cached-commands))))))
  (bnb/load-keybindings)
  ;; Might be good to use this in org-agenda...
  (defun bnb/random-keybinding ()
    "Describe a random keybinding."
    (let* ((command (keywiz-random keywiz-cached-commands))
           (doc (and command (documentation (car command)))))
      (if command
          (concat (symbol-name (car command)) " "
                  "(" (mapconcat 'key-description (cadr command) ", ") ")"
                  (if doc
                      (concat ": " (substring doc 0 (string-match "\n" doc)))
                    ""))
        "")))
#+END_SRC

** Auto-display agenda

    From
    http://lists.gnu.org/archive/html/emacs-orgmode/2010-03/msg00367.html,
    John Weigley shows a way to display the agenda after some period
    of inactivity.

#+BEGIN_SRC emacs-lisp
  (defun bnb/jump-to-org-agenda ()
    (interactive)
    (let ((buf (get-buffer "*Org Agenda*"))
          wind)
      (if buf
          (if (setq wind (get-buffer-window buf))
              (select-window wind)
            (if (called-interactively-p)
                (progn
                  (select-window (display-buffer buf t t))
                  (org-fit-window-to-buffer))
              (with-selected-window (display-buffer buf)
                (org-fit-window-to-buffer))))
         (bnb/org-agenda-with-tip nil))))

  (defun bnb/idle-agenda (&optional arg)
    (interactive "P")
    (setq bnb/iagenda
          (if arg
              (cancel-timer bnb/iagenda)
            (run-with-idle-timer 3600 t 'bnb/jump-to-org-agenda))))

  (when (eq system-type 'windows-nt)
    (bnb/idle-agenda))
#+END_SRC

    The when clause at the end is because I primarily keep my agenda
    information on Windows. No need to have my agenda open on the
    different GNU/Linux boxes all the time.

* Server

   [[info:emacs#Emacs%20Server][Using Emacs as a server]] is a great way to keep the power
   responsive.

#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

   I need to look into the TCP connections to see how
   that work across machines. Perhaps it can be useful in a
   multi-machine work environment.

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load-file custom-file)
#+END_SRC

* Local customizations (user-login-name)

   I also intend to have a generic call to an installed local file
   that may need to behave differently from =custom.el=. This is
   called last so that it can modify any existing setting made here
   to work on the specific system in question.

   In the code below, I add =~/.emacs.d/= to the load path and have a
   protected call to =load-library=.  If the file exists, it gets
   loaded, otherwise the error normally returned if the file is
   non-existant gets ignored.

#+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/")
    (condition-case err
        (progn
          (load-library user-login-name)
          (message "Loaded local settings file %s" user-login-name))
      (file-error
       (message "Skipping %s library as it does not exist." user-login-name))
      nil)
#+END_SRC

* End Timer

   Check how long it took to read this (generated) setup file and
   report in the =*Messages*= buffer.

#+BEGIN_SRC emacs-lisp
  (message "Setup.org loaded in %ds"
           (- (car (cdr (current-time)))
              (car (cdr *emacs-load-start*))))
#+END_SRC
