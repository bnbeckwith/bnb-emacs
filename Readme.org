#+TITLE: BNBECKWITH Tangled Emacs Initialization
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:t html-style:t
#+OPTIONS: html5-fancy:nil tex:t
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.7a)
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+INFOJS_OPT:
#+LATEX_HEADER:
#+PROPERTY: header-args:emacs-lisp :results silent

This document tangles (in literate programming style) the necessary
commands to initialize Emacs to my liking and the documentation for my
choices.

* Installation

  My =init.el= file is quite simple and is generated by the following
  block.  Essentially, I just have to install this package
  (=bnb-emacs=) in the =~/.emacs.d/= directory and run the code block
  (=C-c C-c=) to bootstrap the system.

  #+BEGIN_SRC emacs-lisp :tangle "../init.el" :exports code :results silent
    (require 'package)
    (package-initialize)

    (require 'ob-tangle)
    (org-babel-load-file "~/.emacs.d/bnb-emacs/Readme.org")
  #+END_SRC

  The bootstrapping is simple.  Emacs find =~/.emacs.d/init.el= and
  runs the code. The first step is to initialize the packages I have
  installed via ELPA and others.

  Next, I load =ob-tangle= (part of =org-mode=). Then
  ~org-babel-load-file~ extracts the emacs-lisp code blocks in this
  document and loads the resulting =Readme.org=.

  As I add packages or lines to this document, my initialization is
  already in place and ready to go.

* Personal Information

  The full name is used for email messages.

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Benjamin Beckwith")
  #+END_SRC

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine.

   Here, I set the custom file to reside in my =~/.emacs.d/= directory
   and load it if it exists.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (if (file-exists-p custom-file)
        (load-file custom-file))
  #+END_SRC

* Small Settings

  The next sections encompass some small settings to make Emacs mine.

** Super keys

   I like to be able to use the Windows (or super or hyper) keys for
   shortcuts. I need to take care to not interfere with the
   built-in shortcuts or my bindings will not work.

   #+BEGIN_SRC emacs-lisp
     (setq w32-pass-lwindow-to-system t)
     (setq w32-lwindow-modifier 'super)
   #+END_SRC

** Package archives

   I like to pull from the popular list of package archives.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     (add-to-list 'package-archives '("sr" . "http://joseito.republika.pl/sunrise-commander/") t)
   #+END_SRC

   I install the proper packages with these repositories. This may
   take some time the first time it runs.

   Org-mode and Sunrise Commander have their own repositories that
   keep me on the bleeding edge. They is why they have their own
   repositories above.

  #+BEGIN_SRC emacs-lisp
    ;; Idea lifted from prelude https://github.com/bbatsov/prelude
    (require 'cl)
    (defvar bnb/packages
      '(ace-jump-mode
        ace-isearch
        ace-window
        airplay
        bind-key
        bookmark+
        cider
        clojure-mode
        clojure-mode-extra-font-locking
        color-theme-sanityinc-tomorrow
        company
        company-c-headers
        company-go
        dired+
        edit-server
        expand-region
        guide-key
        helm
        helm-bibtex
        helm-css-scss
        helm-descbinds
        helm-git
        helm-git-files
        helm-helm-commands
        helm-ls-git
        helm-package
        helm-proc
        helm-projectile
        helm-projectile-all
        helm-spaces
        helm-swoop
        helm-themes
        helm-w32-launcher
        hydra
        htmlize
        ido-ubiquitous
        magit
        mc-extras
        multiple-cursors
        org-plus-contrib
        paredit
        powerline
        projectile
        rainbow-mode
        smart-tabs-mode
        smyx-theme
        sublime-themes
        sunrise-commander
        undo-tree
        wc-goal-mode
        writegood-mode))

    (defun bnb/packages-installed-p ()
      (loop for p in bnb/packages
            when (not (package-installed-p p)) do (return nil)
            finally (return t)))

    (unless (bnb/packages-installed-p)
      ;; Need to update package contents
      (message "%s" "Emacs refreshing package contents...")
      (package-refresh-contents)
      (message "done.")

      ;; install the missing packages
      (dolist (p bnb/packages)
        (when (not (package-installed-p p))
          (package-install p))))
  #+END_SRC

** Binding Keys

   For binding keys, I use the =bind-key= package. Not only does it
   easily bind keys, but it does so with some nice features.

   #+BEGIN_SRC emacs-lisp
     (require 'bind-key)
   #+END_SRC


   By using =bind-key=, you can specify the keystrokes that invoke a
   command. This is regular behavior that you can already achieve in
   Emacs and will result in a global binding.

   If you also want to override any possible minor-mode bindings of
   the same keys, you can use =bind-key*= instead.

   There is also an =unbind-key= to, of course, remove any binding.

   The real kicker is that it will keep track of these bindings and
   let you see a summary of your customizations with

: M-x describe-personal-keybindings

** Helm Initialization
    #+BEGIN_SRC emacs-lisp
      (require 'helm-config)

      (bind-key "C-c h" 'helm-command-prefix)

      (setq helm-quick-update                      t
            helm-split-window-in-side-p            t
            helm-buffers-fuzzy-matching            t
            helm-move-to-line-cycle-in-source      t
            helm-ff-search-library-in-sexp         t
            helm-mode-reverse-history              nil
            helm-scroll-amount                     8
            helm-ff-file-name-history-use-recentf  t)

      (helm-mode t)
    #+END_SRC

** Personal Keymaps

   These are inspired from
   [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html]].

*** Common Launcher

    This method (=helm=) inspired from http://kitchingroup.cheme.cmu.edu/blog/2015/02/04/Helm-at-the-Emacs/.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/helm-map-launcher ()
          "Use help to launch various mappings"
        (interactive)
        (helm :sources
              `(((name . "Applications")
                         (candidates . (("Calc" . calc)
                                        ("EDiff Buffers" . ediff-buffers)
                                        ("Find Dired" . find-dired)
                                        ("lgrep" . lgrep)
                                        ("rgrep" . rgrep)
                                        ("ielm" . ielm)
                                        ("proced" . proced)
                                        ("keybindings" . describe-personal-keybindings)
                                        ("Forcast" . sunshine-forecast)))
                         (action . (("Open" . (lambda (x) (funcall x))))))
                helm-source-recentf
                helm-source-bookmarks
                helm-source-bookmark-set)))

      (bind-key "C-x g" 'bnb/helm-map-launcher)

    #+END_SRC

*** Toggle Map

    #+BEGIN_SRC emacs-lisp
      (defun toggle-setting-string (setting)
        (if (and (boundp setting) setting) '[on] '[off]))

      (bind-key
       "C-x t"
       (defhydra hydra-toggle (:color amaranth)
         "
      _c_ column-number : %(toggle-setting-string column-number-mode)
      _e_ debug-on-error: %(toggle-setting-string debug-on-error)
      _u_ debug-on-quit : %(toggle-setting-string debug-on-quit)
      _f_ auto-fill     : %(toggle-setting-string auto-fill-function)
      _t_ truncate-lines: %(toggle-setting-string truncate-lines)
      _r_ read-only     : %(toggle-setting-string buffer-read-only)
      _w_ whitespace    : %(toggle-setting-string whitespace-mode)
      "
         ("c" column-number-mode nil)
         ("e" toggle-debug-on-error nil)
         ("u" toggle-debug-on-quit nil)
         ("f" auto-fill-mode nil)
         ("t" toggle-truncate-lines nil)
         ("r" dired-toggle-read-only nil)
         ("w" whitespace-mode nil)
         ("q" nil)))
    #+END_SRC

*** Elisp Maps

    #+BEGIN_SRC emacs-lisp
      (bind-key
       "C-c e"
       (defhydra hydra-elisp-cmds (:color blue)
         ("b" do-eval-buffer "eval buffer")
         ("e" toggle-debug-on-error "debug-on-error")
         ("f" emacs-lisp-byte-compile-and-load "byte-compile-and-load")
         ("r" eval-region "eval-region")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (bind-key
       "C-h e"
       (defhydra hydra-elisp-help (:color blue)
         ("e" view-echo-area-messages "view-echod-area-messages")
         ("f" find-function "find-function")
         ("k" find-function-on-key "find-function-on-key")
         ("l" find-library "find-library")
         ("v" find-variable "find-variable")
         ("V" apropos-value "apropos-value")
         ("i" info-display-manual "info-display-manual")))
    #+END_SRC

** Minibuffer History Save

   This saves the minibuffer histories to preserve across emacs
   sessions.

   #+BEGIN_SRC emacs-lisp
     (setq savehist-additional-variables
           '(search-ring regexp-search-ring)
           savehist-file "~/.emacs.d/savehist")
     (savehist-mode t)
   #+END_SRC

** Display times

   This block sets up a list of timezones and locations to display
   when calling ~display-time-world~. I also bind a key to get to the
   information quickly.

   #+BEGIN_SRC emacs-lisp
     (setq display-time-world-list
           '(("EST5EDT" "Hudson")
             ("CST6CST" "Iowa")
             ("MST7MST" "Fort Collins")
             ("PST8PDT" "DuPont")))

     (bind-key "C-c C-z" 'display-time-world)
   #+END_SRC

** Abbrev

   The following block is courtesy of [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]].

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-i" 'bnb/ispell-word-then-abbrev)

     (defun bnb/ispell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction
     made. With prefix P, create local abbrev. Otherwise, it will be
     global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft))))

     (setq save-abbrevs t)
     (setq-default abbrev-mode t)
   #+END_SRC

** Hippie Expand

   Try to expand the text before point in an intelligent way. Repeat
   the keypress to cycle through options.

   #+BEGIN_SRC emacs-lisp
     (bind-key "M-/" 'hippie-expand)
   #+END_SRC

** Emacs Bookmarks

   [[http://emacswiki.org/emacs/BookMarks]]

   | Keystroke           | Action                  |
   |---------------------+-------------------------|
   | C-x r m             | Set a bookmark          |
   | C-x r b             | Jump to a bookmark      |
   | C-x r l             | List your bookmarks     |
   | M-x bookmark-delete | Delete bookmark by name |

   I will auto-save my bookmarks.

   #+BEGIN_SRC emacs-lisp
     (setq bookmark-save-flag t)
   #+END_SRC

** Writegood Mode

   This mode installs through the ELPA system.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c g" 'writegood-mode)
     (bind-key "C-c C-g g" 'writegood-grade-level)
     (bind-key "C-c C-g e" 'writegood-reading-ease)
   #+END_SRC

** Development

   For any lisp development, the following is nice to have.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
   #+END_SRC

   While developing, documentation is nice to have handy and
   automatic.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'cperl-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'eshell-mode-hook 'turn-on-eldoc-mode)
   #+END_SRC

** Encryption

   [[info:epa#Top][EasyPG Assistant]] helps with integration of GnuPG.  The command
   below turns on the automatic encryption/decryption of =*.gpg=
   files.

   #+BEGIN_SRC emacs-lisp
     (require 'epa)
     (epa-file-enable)
   #+END_SRC

   It is possible that you would need to [[elisp:(customize-group%20'epg)][customize the location of
   gpg]].

** Read-only helpers

   For read-only files, look at them in =view-mode= which will enable
   vi-style navigation.

   #+BEGIN_SRC emacs-lisp
     (require 'view)
     (setq view-read-only t)     ; enter view-mode for read-only files
     (bind-key "n" 'next-line     view-mode-map)
     (bind-key "p" 'previous-line view-mode-map)
     (bind-key "j" 'next-line     view-mode-map)
     (bind-key "k" 'previous-line view-mode-map)
   #+END_SRC

** Default File encoding

   I like to have the files be =utf-8= by default. Do
   let me know if I shouldn't do this, will you?

   Set =utf-8= for all coding systems except for the clipboard on
   windows.  That one gets =utf-16le= to be compatible.

   #+BEGIN_SRC emacs-lisp
     (prefer-coding-system       'utf-8)
     (set-default-coding-systems 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-language-environment 'utf-8)
     (setq default-buffer-file-coding-system 'utf-8)
     (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
     ;; MS Windows clipboard is UTF-16LE
     (when (eq system-type 'windows-nt)
       (set-clipboard-coding-system 'utf-16le-dos))
   #+END_SRC

** Vimrc generic mode

   Good to have to help with my pentadactyl configuration as it is in
   a vim-style of configuration.

   #+BEGIN_SRC emacs-lisp
     (define-generic-mode 'vimrc-generic-mode
       '()
       '()
       '(("^[\t ]*:?\\(!\\|ab\\|map\\|unmap\\)[^\r\n\"]*\"[^\r\n\"]*\\(\"[^\r\n\"]*\"[^\r\n\"]*\\)*$"
          (0 font-lock-warning-face))
         ("\\(^\\|[\t ]\\)\\(\".*\\)$"
          (2 font-lock-comment-face))
         ("\"\\([^\n\r\"\\]\\|\\.\\)*\""
          (0 font-lock-string-face)))
       '("/vimrc\\'" "\\.vim\\(rc\\)?\\'")
       '((lambda ()
           (modify-syntax-entry ?\" ".")))
       "Generic mode for Vim configuration files.")
   #+END_SRC

** Ediff single frame

   I really dislike the multi-frame mode of =ediff=.  It is confusing
   to use and really messes up my [[http://dwm.suckless.org][dwm]] usage. By explicitly setting
   the following setting, it forces =ediff= to use only one
   frame.

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC

   Now the control window will be a small window instead of a
   separate frame.

** Magit

   [[info:magit#Top][Magit]] is a git interface for Emacs.

   Here I set a global key for ~magit-status~. Think 'G' looks
   like 6.

   #+BEGIN_SRC emacs-lisp
     (bind-key "<f6>" 'magit-status)
   #+END_SRC

** Open/Edit This file

   When I hit ~<F5>~, open this file for editing.  That way, any
   time I have something I need to remember for my emacs setting, it
   is just a button-push away.

   #+BEGIN_SRC emacs-lisp
     (bind-key "<f5>"
               (lambda ()
                 (interactive)
                 (find-file "~/.emacs.d/bnb-emacs/Readme.org")))
   #+END_SRC

** Sounds

   I dislike the bell ringing when I hit =C-g=. To silence the bell,
   just set the =ring-bell-function= to =nil=.

   #+BEGIN_SRC emacs-lisp
     (setq visual-bell nil)
     (setq ring-bell-function `(lambda () nil))
   #+END_SRC

** Midnight Mode

   This mode looks at midnight and kills any inactive buffers. By
   default, /inactive/ means is any buffer untouched for three days.

   #+BEGIN_SRC emacs-lisp
     (require 'midnight)
   #+END_SRC

** Sunrise Commander

   Sunrise commander is Emacs' answer to the popular Midnight
   Commander. I have a global key below to launch the default
   interface.

   I also turn off help for jumping directories.  For Sunrise, I find
   the ido interface better.

   #+BEGIN_SRC emacs-lisp
     (bind-key "s-/" 'sunrise)

     (add-to-list 'helm-completing-read-handlers-alist
                  '(sr-goto-dir . ido))
   #+END_SRC

*** Interesting Keys

    | Key    | Purpose                        |
    |--------+--------------------------------|
    | C-cC-s | Switch horizontal/vertical/top |
    | m      | Mark a file for action         |
    | j      | Jump to a different directory  |
    | J      | Move up a directory            |
    | n      | Move cursor to next item       |
    | p      | Move cursor to previous item   |
    | R      | Rename (move) marked file      |
    | q      | Quit                           |
    | v      | Quick view file                |

*** Org Links in Sunrise Commander

    Storing links from Sunrise-commander

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-store-link-functions 'org-diredish-store-link)

      (defun org-diredish-store-link ()
        "Store link to files/directories from dired."
        (when (derived-mode-p 'dired-mode)
          (let ((f (dired-filename-at-point)))
            (setq link (concat "file+system" ":" f)
                  desc (concat f " (dired)"))
            (org-add-link-props :link link :description desc)
            link)))

    #+END_SRC

*** Visual display

    To improve the listings view of =dired=, I use the following (from
    [[http://oremacs.com/2015/01/13/dired-options/]])

    #+BEGIN_SRC emacs-lisp
      (setq sr-listing-switches "-alhG1vu")
    #+END_SRC

    This makes the following settings

    - l :: mandatory
    - a :: list invisible files
    - G :: omit group information
    - h :: human readable sizes
    - 1v :: Sort digits correctly

** Guide Key

   Provide a guide for long (and easy to forget) key sequences.  The
   prefixes below, such as =C-x r=, have numerous options that can
   follow.  This mode helpfully shows what options are available in a
   small bottom window.

   #+BEGIN_SRC emacs-lisp
     (require 'guide-key)
     (setq guide-key/guide-key-sequence
           '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x x" "C-c h"))
     (guide-key-mode 1)
     (setq guide-key/recursive-key-sequence-flag t)
     (setq guide-key/popup-window-position 'bottom)
   #+END_SRC

** Ace Utilities
*** Ace Jump

    I use ace-isearch to overload the =C-s= key and use ace-jump in
    that way.

*** Ace Isearch

    #+BEGIN_SRC emacs-lisp
      (global-ace-isearch-mode t)
      (setq ace-isearch-input-idle-delay 1.4)
    #+END_SRC

*** Ace Window

    Instead of =C-x o= traversal, =ace-window= mode provides numbers
    for quick window access

    Set the keys to something other than the default numbers. Note
    that this also limits the number of windows that can be used, but
    given my usage, I doubt it goes up to 'j' often.

    Also, I modify the face attribute to make the window numbers large.

    #+BEGIN_SRC emacs-lisp
      (require 'ace-window)
      (bind-key "s-a" 'ace-window)
      (bind-key "C-s-a" 'aw-flip-window)
      (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l))
      (set-face-attribute 'aw-leading-char-face nil :height 2.0)
    #+END_SRC

** Edit Server

   The edit server talks to Chrome and uses emacs to edit any
   textareas.  I start this server here.

   #+BEGIN_SRC emacs-lisp
     (edit-server-start)
   #+END_SRC

   Chrome needs to have the proper extension installed there too for
   the installation to be complete.

** Regexp-Builder

   Emacs regular expressions are not the easiest to use out of the
   box. Emacs now has [[help:re-builder][regexp-builder]] to assist you in building the
   correct regexp as you type.

   However, to complicate matters, there are five different /syntaxes/
   of regular expression that the builder can use.  The =string=
   syntax is what I tend to use most in searching and replacing, so I
   will make that my default.

   #+BEGIN_SRC emacs-lisp
     (setq reb-re-syntax 'string)
   #+END_SRC

   | Key Binding | Meaning                                    |
   |-------------+--------------------------------------------|
   | C-c TAB     | Switch syntax                              |
   | C-c C-e     | Sub-expression mode (show matching groups) |
   | C-c C-s/r   | Search forward/backward                    |
   | C-c C-w     | Copy regexp to kill ring                   |
   | C-c C-q     | Quit the builder                           |

   Be sure to consult the [[info:emacs#Regexps][syntax of regular expressions]] to learn more
   about the weird backslashing.

** IBuffer

   Use ~ibuffer~ instead of ~list-buffers~ for buffer management. The
   most visible difference being the coloring that ~ibuffer~ uses.

   I also squash any empty groups from being displayed and add hooks
   to automatically set the filter groups and update contents.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-b" 'ibuffer)

     (setq ibuffer-show-empty-filter-groups nil)

     (add-hook 'ibuffer-mode-hook
               '(lambda ()
                  (ibuffer-auto-mode 1)
                  (ibuffer-switch-to-saved-filter-groups "Standard")))
   #+END_SRC

*** Groups

    The buffer list splits into arbitrary groups for easier
    management. Below I create an "Org" group for ~org-mode~ buffers.

    #+BEGIN_SRC emacs-lisp
      (setq ibuffer-saved-filter-groups
            '(("Standard"
               ("Emacs" (or (filename . ".*bnb-emacs.*")
                            (mode . emacs-lisp-mode)))
               ("Org" (mode . org-mode))
               ("Magit" (name . "\*magit"))
               ("Mail" (or (mode . message-mode)
                           (mode . mail-mode)))
               ("HTML" (mode . html-mode))
               ("Help" (or (name . "\*Help\*")
                           (name . "\*Apropos\*")
                           (name . "\*info\*"))))))

    #+END_SRC


**** VC Grouping

     =M-x ibuffer-vc-set-filter-groups-by-vc-root=

** Multiple Cursors

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x M" 'compose-mail)
     (unbind-key "C-x m" ) ;; remove mail binding

     (bind-key
      "C-x m"
      (defhydra hydra-mc ()
        "mc bind-key"
        ("a" mc/mark-all-like-this-dwim "all")
        ("n" mc/mark-next-like-this "next")
        ("e" mc/edit-lines "all lines")
        ("w" mc/mark-next-word-like-this "next word")
        ("W" mc/mark-all-words-like-this "all words")
        ("r" mc/mark-all-in-region-regexp "regexp")
        ("j" mc/mark-next-lines "next lines")
        ("k" mc/mark-previous-lines "prev lines")
        ("p" mc/mark-sgml-tag-pair "tag pairs")
        ("x" mc/mark-more-like-this-extended "arrows")))
   #+END_SRC

** Expand Region

   Nice way to expand selections to semantic regions. Read more on
   [[https://github.com/magnars/expand-region.el]].

   #+BEGIN_SRC emacs-lisp
     (bind-key (kbd "C-=") 'er/expand-region)
   #+END_SRC

** Hooks

   In general, hooks may be best with other configuration items, but
   if they are just pieces on their own, they belong here.

*** Ensure proper lisping

    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-save-hook  'check-parens nil t)
    #+END_SRC

*** Auto Reverting in modes

    For view-only buffers rendering content, it is useful to have them
    ~auto-revert~ in case of changes.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'doc-view-mode-hook 'auto-revert-mode)
      (add-hook 'image-mode 'auto-revert-mode)
    #+END_SRC

** Recentf

   First, I need to enable this mode to gain the functionality.

   #+BEGIN_SRC emacs-lisp
     (recentf-mode t)
   #+END_SRC

*** Opening Recent files with IDO

    From the [[http://www.emacswiki.org/emacs/RecentFiles#toc7][EmacsWiki]], the following code helps open recent files
    quickly.

    #+BEGIN_SRC emacs-lisp
      (defun recentf-ido-find-file ()
        "Find a recent file using Ido."
        (interactive)
        (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
          (when file
            (find-file file))))
      (bind-key "C-x C-r" 'recentf-ido-find-file)
    #+END_SRC

** Executable Scripts on save

   Taken from: http://mbork.pl/2015-01-10_A_few_random_Emacs_tips

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC

* Style

** Frame Changes

   These following items make Emacs really beautiful on every
   platform.  I remove the menu bar, tool bar and the scroll bar for
   starters.  Then, I setup the fringe area with some items

   #+BEGIN_SRC emacs-lisp
     (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
     (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
   #+END_SRC

** Window Changes

   #+BEGIN_SRC emacs-lisp
     (setq-default indicate-buffer-boundaries 'right)
     (setq-default indicate-empty-lines t)
     (setq-default frame-title-format '("%b - %F"))
   #+END_SRC

** Faces
*** Default Fonts

    On windows, I have /Source Code Pro/ installed.  Let's use that
    there.

    #+BEGIN_SRC emacs-lisp
      (when (eq system-type 'windows-nt)
        (set-face-attribute 'default nil :font "Source Code Pro-10"))
    #+END_SRC

    Setup a strike-through font for agenda items. The /done/ items
    are now easily overlooked within an agenda or task list.

    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'org-agenda-done nil :strike-through t)

      (defadvice enable-theme (after org-strike-done activate)
        "Setup org-agenda-done faces to have strike-through on"
        (and (message "Running advice")
             (set-face-attribute 'org-agenda-done nil :strike-through t)))
    #+END_SRC


**** Trying out fonts on Windows

     #+BEGIN_SRC emacs-lisp
       (defun bnb/set-font ()
         (interactive)
         (set-face-attribute 'default nil :font (w32-select-font)))
     #+END_SRC

*** Dynamic Font sizes

    Changing font sizes in presentations is crucial to have at hand. I
    use the following keybindings. =C--= overrides the negative
    argument function, but that one is also accessible by =M--=.

    #+BEGIN_SRC emacs-lisp
      (bind-key "C-+" 'text-scale-increase)
      (bind-key "C--" 'text-scale-decrease)
    #+END_SRC

*** Mode Line Style

    I dislike the box around the =mode-line= making it look like a
    button.  I disable (set to =nil=) this face attribute, =box=, to
    get a flat feel.  Be sure to do it to all =mode-line= faces that
    have this attribute.

    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'mode-line nil :box nil)
      (set-face-attribute 'mode-line-inactive nil :box nil)
      (set-face-attribute 'mode-line-highlight nil :box nil)
    #+END_SRC

*** Missing Glyphs

    If I ever use a font with a missing glyph, this will let Emacs
    check the /Symbola/ font for the missing data.

    [[http://users.teilar.gr/~g1951d/][Download Symbola]] if you do not have it.

    #+BEGIN_SRC emacs-lisp
      (set-fontset-font "fontset-default" nil
                        (font-spec :size 20 :name "Symbola"))
    #+END_SRC

** Powerline

   [[https://github.com/milkypostman/powerline][Powerline]] is a modification to the mode-line based on some
   vim-customizations.

   #+BEGIN_SRC emacs-lisp
     (require 'powerline)
     (setq powerline-default-separator 'slant)
     (powerline-default-theme)
   #+END_SRC

** Themes

   My favorite dark themes are =smyx= or =fogus=.  I have yet to find
   a pleasing light theme, though =mccarthy= is close.

   You can layer themes by enabling them in turn, but this is not the
   default usage for most of us. Github user =larstvei= has the
   following advice for that case.

   #+BEGIN_SRC emacs-lisp
     (defadvice load-theme
       (before disable-theme-before-load (theme &optional no-confirm no-enable) activate)
       (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

   It also seems that I have to reset =powerline= when running a new
   theme. The next piece of advice does that for me.

   #+BEGIN_SRC emacs-lisp
     (defadvice load-theme
       (after theme-reset-powerline (theme &optional no-confirm no-enable) activate)
       (powerline-reset))
   #+END_SRC

* BNB Helpers

  This is a collection of code specific to how I use emacs.  Some
  are from different websites or other Emacs users.

** Exit behavior

   Instead of exiting emacs, I prefer to leave it running and only
   minimize (iconize) it. Especially since I use =server= with emacs,
   it is advantageous to not kill my session by accident
   (muscle-memory). This idea is from [[http://emacs-fu.blogspot.com/2009/03/windows-and-daemons.html][Emacs-Fu]].

   To accomplish this, I advise the =kill-emacs= function. But first,
   I need to have some pieces in place to perform some functionality
   if a killing operation triggers (keystrokes, button presses,
   etc).

   I create a variable, =bnb/kill-emacs-hooks=, for functions that
   need to run before emacs is /killed/.

   #+BEGIN_SRC emacs-lisp
     (defvar bnb/kill-emacs-hooks)
     (add-hook 'bnb/kill-emacs-hooks
               (lambda () (if (functionp 'server-edit)(server-edit))))
   #+END_SRC

   In the hook above, I call the =server-edit= function to act as if
   I am closing emacs for a file opened via the server API. This has
   the effect of providing an illusion of opening the editor on a
   specific file and then closing it with normal keypresses.

   Next, I provide a flag and a function to set the flag if emacs is
   to really exit. We always need an escape hatch.

   #+BEGIN_SRC emacs-lisp
     (defvar bnb/really-kill-emacs nil)
     (defun bnb/kill-emacs ()
       (interactive)
       (setq bnb/really-kill-emacs t)
       (kill-emacs))
   #+END_SRC

   Now that mechanism is in place, it is time to augment
   =kill-emacs= with some advice around the function.

   #+BEGIN_SRC emacs-lisp
     (defadvice kill-emacs (around bnb/pardon-emacs activate)
       "Only kill emacs if a prefix is set"
       (run-hooks 'bnb/kill-emacs-hooks)
       (if bnb/really-kill-emacs
           ad-do-it
         (when (eq system-type 'windows-nt)
           (iconify-frame))))
   #+END_SRC

   Now, when any event triggers a call to =kill-emacs=, a small set
   of activities happen. First, the =bnb/kill-emacs-hooks= execute
   and perform their jobs. Next, I check the flag for /really/
   exiting and then call the proper =kill-emacs= if true. Otherwise,
   the flag is false and emacs is simply iconified.

** Workweeks

   #+BEGIN_SRC emacs-lisp
       (defun bnb/workweek ()
         (interactive)
         (let* ((now (current-time))
                (weeks (string-to-number
                        (format-time-string "%W" now)))
                (days (time-to-day-in-year now))
                (daynum (string-to-number
                         (format-time-string "%w" now)))
                (left (% days 7)))
           (if (and (= 0 daynum) (= left 0))
               weeks
             (+ 1 weeks))))

       (defun bnb/workweek-string ()
         (interactive)
         (concat "WW"
                 (number-to-string
                  (bnb/workweek))))

     (require 'calendar)
     (defun bnb/workweek-from-gregorian (&optional date)
       (let* ((date (or date (calendar-current-date)))
              (year (calendar-extract-year date))
              (fst (calendar-day-of-week (list 1 1 year)))
              (x   (if (>= fst 4)1 0)))
         (+ x
            (car
             (calendar-iso-from-absolute
              (calendar-absolute-from-gregorian date))))))

     (setq calendar-week-start-day 1
           calendar-intermonth-text
             '(propertize
               (format "%2d"
                       (bnb/workweek-from-gregorian (list month day year)))
               'font-lock-face 'font-lock-function-name-face))

   #+END_SRC

** Better window splitting functions

   http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

   These settings split the window and load a previous buffer (instead
   of the same buffer in both).  This has a better chance of being
   what I want when splitting strings.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/vplit-last-buffer ()
       (interactive)
       (split-window-vertically)
       (other-window 1 nil)
       (switch-to-next-buffer))

     (defun bnb/hsplit-last-buffer ()
       (interactive)
       (split-window-horizontally)
       (other-window 1 nil)
       (switch-to-next-buffer))

     (bind-key "C-x 2" 'bnb/vplit-last-buffer)
     (bind-key "C-x 3" 'bnb/hsplit-last-buffer)
   #+END_SRC
** Weekly Time Reporting

   This is a function to create an entry like a datetree, but using
   years and workweeks instead.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/find-year-create (year)
       (let ((re "^\\**[ \t]+\\([12][0-9]\\{3\\}\\)")
             match)
         (org-narrow-to-subtree)
         (goto-char (point-min))
         (while (and (setq match (re-search-forward re nil t))
                     (goto-char (match-beginning 1))
                     (< (string-to-number (match-string 1)) year)))
         (cond
          ((not match)
           (goto-char (point-max))
           (or (bolp) (newline))
           (insert (format  "** %s\n" year)))
          ((= (string-to-number (match-string 1)) year)
           (goto-char (point-at-bol)))
          (t
           (beginning-of-line 1)
           (insert (format  "** %s\n" year))))))

     (defun bnb/find-ww-create (ww)
       (let ((re "^\\**[ \t]+\\WW\\([0-9]\\{2\\}\\)")
             match)
         (org-narrow-to-subtree)
         (goto-char (point-min))
         (while (and (setq match (re-search-forward re nil t))
                     (goto-char (match-beginning 1))
                     (< (string-to-number (match-string 1)) ww)))
         (cond
          ((not match)
           (goto-char (point-max))
           (or (bolp) (newline))
           (insert (format "*** WW%02d\n" ww)))
          ((= (string-to-number (match-string 1)) ww)
           (goto-char (point-at-bol)))
          (t
           (beginning-of-line 1)
           (insert (format "*** WW%02d\n" ww))))))

     (defun bnb/insert-weekly-time-sheet ()
       (concat  "#+BEGIN: clocktable :maxlevel 3 :scope agenda-with-archives :block lastweek :fileskip0 t :properties (\"Score\") :indent nil \n"
                "#+TBLFM: $6='(org-clock-time% @2$4 $3..$5);%.1f::@2$2=vsum(@3$2..@>$2)\n"
                "#+END:\n"))

     (defun bnb/insert-weekly-clocking ()
         (let ((year (number-to-string (nth 2 (calendar-gregorian-from-absolute (org-today)))))
               (ww (bnb/workweek)))
           (goto-char (point-min))
           (goto-char (cdr (org-id-find "clocking")))
           (bnb/find-year-create (string-to-number year))
           (bnb/find-ww-create ww)))
   #+END_SRC

* Company

  [[http://company-mode.github.io][Company Mode]] is an in-buffer completion system. To get started, I
  need to load the mode and bind some keys.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'after-init-hook 'global-company-mode)
    (bind-key (kbd "<C-tab>") 'company-complete)
    (bind-key (kbd "<C-tab>") 'company-complete org-mode-map)
    ;; Turn off the auto downcasing of things
    (setq company-dabbrev-downcase nil)
  #+END_SRC

* Dired

  So, I used =dired+= instead of the regular dired. It offers more
  interesting colors and more flexible ways to mark files.

  For example, to mark by extension, press =*.=, then type the
  extension (with dot).

  Here I enable the =dired-find-alternate-file= command. It lets my
  just type =a= to replace the current buffer and reduces the
  accumulating dired buffers.

  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'dired+)
      (package-install 'dired+))
    (put 'dired-find-alternate-file 'disabled nil)
  #+END_SRC

** IDO for switching directories

   I prefer IDO over Helm for switching directories.  It is just
   faster for my fingers.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'helm-completing-read-handlers-alist
                  '(dired-goto-file . ido))
     (add-to-list 'helm-completing-read-handlers-alist
                  '(dired . ido))
   #+END_SRC

* Smart Tabs

  [[http://www.emacswiki.org/emacs-en/SmartTabs][SmartTabs]] try to do the right thing regarding tabs/spaces in
  indentation/alignment. It installs through the package interface. Look for
  =smart-tabs-mode=.

  By default, I'm enabling it in all modes that I can.

  Since we are dealing with tabs here, I also take the time to set
  the default width to 4.  Because of the way this mode works, any
  change in the default width will result in code that still aligns.

  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
    (smart-tabs-insinuate 'c 'javascript 'python 'cperl 'c++)
    (setq-default tab-width 4)
  #+END_SRC

** Notes

   To re-tab the whole file, use =C-x h C-M-\=.

* CUA mode

  [[info:emacs#CUA%20Bindings][CUA]] has a primary feature of enabling cut, copy, paste and undo
  shortcuts compatible with most applications (C-x, C-c,
  C-v). However, it also has interesting rectangle features and
  *that* is why I enable it. I also happen to turn off those other
  bindings and prefer the emacs defaults.

  #+BEGIN_SRC emacs-lisp
    (cua-mode t)
    (setq cua-enable-cua-keys nil)
  #+END_SRC

** Bindings

*** CUA Rectangles

    These take place with an active rectangle. To start/cancel a
    rectangle use =C-RET=.

    | Keys             | Function                                                              |
    |------------------+-----------------------------------------------------------------------|
    | M-<arrow>        | Move rectangle overlay                                                |
    | C-SPACE          | Activate region bounded by rectangle                                  |
    |------------------+-----------------------------------------------------------------------|
    | M-a              | Align all words at the left edge                                      |
    | M-b              | Fill rectangle with blanks (tabs and spaces)                          |
    | M-c              | Closes the rectangle by removing left edge blanks                     |
    | M-f              | Fills the rectangle with a single character (prompt)                  |
    | M-i              | Increases number found on each line of rectangle                      |
    | M-k              | Kills the rectangle as normal multi-line kill                         |
    | M-l              | Downcases the rectangle                                               |
    | M-m              | Copies the rectangle for normal multi-line paste                      |
    | M-n              | Filles each line with increasing numbers (prompt)                     |
    | M-o              | Opens the rect by moving hilighted text right and filling with blanks |
    | M-p              | Toggles virtual straight rectangle edges                              |
    | M-P              | Inserts tabs and spaces to make real straight edges                   |
    | M-q              | Performs text filling on the rectangle                                |
    | M-q              | Performs text filling on the rectangle                                |
    | M-r              | Replaces REGEXP (prompt) by STRING (prompt) in rectangle              |
    | M-R              | Reverse the lines in the rectangle                                    |
    | M-s              | Fills each line of the rectangle with the same STRING (prompt)        |
    | M-t              | Performs text fill of the rectangle with TEXT (prompt)                |
    | M-u              | Upcases the rectangle                                                 |
    | M-<Vertical Bar> | Runs shell command on rectangle                                       |
    | M-'              | Restricts rectangle to lines with CHAR (prompt) at left column        |
    | M-/              | Restricts rectangle to lines matching REGEXP (prompt)                 |
    | C-?              | Shows a brief list of the above commands.                             |
    |------------------+-----------------------------------------------------------------------|
    | M-C-<UP/DOWN>    | Scrolls the lines INSIDE the rectangle up/down                        |

*** CUA Global Mark

    The global mark feature enables a target the receives any
    typed/copied/killed text from any buffer (even the current one).

    | Key           | function                                                                                                            |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | <ch>          | All characters (including newlines) you type are inserted at the global mark!                                       |
    | C-x           | If you cut a region or rectangle, it is automatically inserted at the global mark, and the global mark is advanced. |
    | C-c           | If you copy a region or rectangle, it is immediately inserted  at the global mark, and the global mark is advanced. |
    | C-v           | Copies a single character to the global mark.                                                                       |
    | C-d           | Moves (i.e. deletes and inserts) a single character to the global mark.                                             |
    | backspace     | deletes the character before the global mark                                                                        |
    | delete        | deletes the character after the global mark.                                                                        |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | S-C-space     | Jumps to and cancels the global mark.                                                                               |
    | C-u S-C-space | Cancels the global mark (stays in current buffer).                                                                  |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | TAB           | Indents the current line or rectangle to the column of the global mark.                                             |


* Paredit

  I added =paredit-mode= to several of the lisp modes that follow.

  [[http://www.emacswiki.org/emacs/PareditCheatsheet][Paredit Cheatsheet]]

  [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][Animated Paredit]]

* Projectile

  Handling project buffers and files may be easier with projectile.
  Currently under evaluation.

  #+BEGIN_SRC emacs-lisp
    (when (eq system-type 'windows-nt)
      (setq projectile-indexing-method 'native))
    (setq projectile-enable-caching t)
    (setq projectile-require-project-root t)
  #+END_SRC

* Clojure

  The easiest way to edit clojure code is with =paredit= so let's have
  it automatically load each time.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'clojure-mode-hook 'paredit-mode)
  #+END_SRC

** Cider

   Using Cider will make a nREPL available for Clojure
   programming. The configuaration snippets here are from the [[https://github.com/clojure-emacs/cider][project
   page on github]].

   #+BEGIN_SRC emacs-lisp
     ;; Enable eldoc
     (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)

     ;; Hide special buffers
     (setq nrepl-hide-special-buffers t)

     ;; Stop the error from popping up while working in buffers other than the REPL
     (setq cider-popup-stacktraces nil)

     ;; Stop prompting to save file when killing repl buffer
     (setq cider-prompt-save-file-on-load nil)
   #+END_SRC

* Elisp

  When modified =emasc-lisp=, it is most helpful to use =paredit= and
  =eldoc=.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

* Helm

  Helm Initialization is done above.

** Helm Hydra interface

   From
   http://angelic-sedition.github.io/blog/2015/02/03/a-more-evil-helm/,

   #+BEGIN_SRC emacs-lisp
     (bind-key "<escape>"
               (defhydra helm-like-unite ()
                 "vim movement"
                 ("?" helm-help "help")
                 ("<escape>" keyboard-escape-quit "exit")
                 ("<SPC>" helm-toggle-visible-mark "mark")
                 ("a" helm-toggle-all-marks "(un)mark all")
                 ("/" (lambda ()
                        (interactive)
                        (execute-kbd-macro [?\C-s]))
                  "search")
                 ("v" helm-execute-persistent-action)
                 ("g" helm-beginning-of-buffer "top")
                 ("G" helm-end-of-buffer "bottom")
                 ("j" helm-next-line "down")
                 ("k" helm-previous-line "up")
                 ("l" helm-next-source "next source")
                 ("i" nil "cancel"))
               helm-map)
   #+END_SRC

** Helm for regexp

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c h x" 'helm-regexp)
   #+END_SRC

** Helm Kill Ring

   #+BEGIN_SRC emacs-lisp
     (bind-key "M-y" 'helm-show-kill-ring)
   #+END_SRC

** Helm Colors
   - helm-action
   - helm-bookmark-addressbook
   - helm-bookmark-directory
   - helm-bookmark-file
   - helm-bookmark-gnus
   - helm-bookmark-info
   - helm-bookmark-man
   - helm-bookmark-w3m
   - helm-buffer-directory
   - helm-buffer-file
   - helm-buffer-not-saved
   - helm-buffer-process
   - helm-buffer-saved-out
   - helm-buffer-size
   - helm-candidate-number
   - helm-ff-directory
   - helm-ff-executable
   - helm-ff-file
   - helm-ff-invalid-symlink
   - helm-ff-prefix
   - helm-ff-symlink
   - helm-grep-cmd-line
   - helm-grep-file
   - helm-grep-finish
   - helm-grep-lineno
   - helm-grep-match
   - helm-grep-running
   - helm-header
   - helm-helper
   - helm-history-deleted
   - helm-history-remote
   - helm-lisp-completion-info
   - helm-lisp-show-completion
   - helm-locate-finish
   - helm-match
   - helm-moccur-buffer
   - helm-prefarg
   - helm-resume-need-update
   - helm-selection
   - helm-selection-line
   - helm-separator
   - helm-source-header
   - helm-swoop-target-line-block-face
   - helm-swoop-target-line-face
   - helm-swoop-target-word-face
   - helm-visible-mark

** Helm Spaces

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c h s" 'helm-spaces)
   #+END_SRC
** Helm Mini

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x b" 'helm-mini)
   #+END_SRC
** Helm Descbinds

   Describe keybindings in the current modes.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-h b" 'helm-descbinds)
   #+END_SRC
** Helm W32 Launcher

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c h g" 'helm-w32-launcher)
   #+END_SRC
* IDO (Interactively Do Things)

  EDIT: This is being replace by helm in my workflow.

  I do not believe I could live without this on emacs. Even for just
  finding files, it is awesome.

  First, I start with some basic IDO settings. I enabled it
  everywhere so that it will work in all contexts. I like flex
  matching so I also turn that feature on. Finally, I order the file
  extensions to my liking and enable the mode.

  #+BEGIN_SRC emacs-lisp
    ;(setq ido-everywhere t)
    (setq ido-enable-flex-matching t)
    ; Do not ask to create a new buffer -- just do it.
    (setq ido-create-new-buffer 'always)
    ; Try to guess if point is at a filename
    (setq ido-use-filename-at-point 'guess)
    ; Set extension ordering
    (setq ido-file-extensions-order '(".org" ".tex" ".el" ".txt" ".c" ".cpp" ".h" ".clj"))
    ; Enable mode
    ; (ido-mode t)
  #+END_SRC

  Additionally, I use the [[https://github.com/technomancy/ido-ubiquitous][ido-ubiquitous]] package to /really/ get =ido=
  everywhere. Install it via the package system and then enable it
  on startup.

  #+BEGIN_SRC emacs-lisp
    ;(ido-ubiquitous t)
  #+END_SRC

** IDO Ubiquitous Settings

   Here is a setting that disables =ido-ubiquitous= completion from
   any commands listed.  I have =insert-char= here (called with
   =C-x 8 <RET>=) because I like to see the buffer of UTFâ€‘8 names
   for completion.

   #+BEGIN_SRC emacs-lisp
     (setq ido-ubiquitous-command-exceptions '(insert-char execute-extended-command))
   #+END_SRC

** Smex

   [[http://www.emacswiki.org/emacs/Smex][Read more about Smex on the Emacs Wiki]]

   This builds on top of =ido-mode= which is why it is here.
   This provides better =M-x= functionality.

   #+BEGIN_SRC emacs-lisp
     ;(bind-key "M-x" 'smex)
     ;(bind-key "M-X" 'smex-major-mode-commands)
     ;(bind-key "C-c C-c M-x" 'execute-extended-command)
   #+END_SRC

   One of the nice things about the default command selection (read
   non-ido) is the ability to type " " and have it expand to
   "-". This is possible again with a bit of advice.

   #+BEGIN_SRC emacs-lisp
     (defadvice smex (around space-inserts-hyphen activate compile)
       (let ((ido-cannot-complete-command
              `(lambda ()
                 (interactive)
                 (if (string= " " (this-command-keys))
                     (insert ?-)
                   (funcall ,ido-cannot-complete-command)))))
         ad-do-it))
   #+END_SRC

** Keystrokes

   | Keystroke | Operates on        | Description                            |
   |-----------+--------------------+----------------------------------------|
   | C-b       | Buffers            | Reverts to the old switch-buffer       |
   | C-f       | Files              | Reverts to the old find-file           |
   | C-d       | Dirs/Files         | Opens a dired buffer in current dir    |
   | C-a       | Files/Buffers      | Toggles showing ignored files          |
   | C-c       | Buffers/Dirs/Files | Toggles ignore case for names          |
   | TAB       | Buffers/Dirs/Files | Attempt to complete input              |
   | C-p       | Files              | Toggles prefix matching                |
   | C-s/C-r   | All                | Moves to next/previous match           |
   | C-t       | All                | Toggles matching Emacs Regexp          |
   | Backspace | All                | Deletes chars or up directory          |
   | C-SPC/C-@ | All                | Restricts completion list              |
   | //        | Dirs/Files         | Ignore preceding path                  |
   | ~/        | Dirs/Files         | Jump to home directory                 |
   | M-d       | Files              | Searches for input in cwd sub-dirs     |
   | C-k       | Buffers/Files      | Kills focused buffer or deletes file   |
   | M-m       | Files              | Creates a new sub-dir to cwd           |
   | M-n/M-p   | Dirs/Files         | Cycles through next/previous work dirs |
   | M-k       | Dirs/Files         | Kills active work dir from list        |
   | M-s M-s   | Dirs/Files         | Search list of work dirs for input     |

* Shells

  There are two useful shells in emacs: =eshell= and
  =ansi-term=.

** Eshell

   Built-in Eshell can provide a shell that works the same on windows or
   GNU/Linux. One of the really cool features is that you can define
   commands to use (like aliases) within the shell and have them
   directly integrate with emacs.

   #+BEGIN_SRC emacs-lisp
     (defun eshell/emacs (&rest args)
       "Open a file in emacs the natural way"
       (if (null args)
           ;; If emacs is called by itself, then just go to emacs directly
           (bury-buffer)
         ;; If opening multiple files with a directory name, e.g.
         ;; > emacs bar/bar.txt foo.txt
         ;; then the names must be expanded to complete file paths.
         ;; Otherwise, find-file will look in the current directory which
         ;; would fail for 'foo.txt' in the example above.
         (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
   #+END_SRC

*** Plan 9 Smart Shells

    See [[http://www.masteringemacs.org/article/complete-guide-mastering-eshell][the complete guide to mastering Eshell]] for more on this.
    Basically, the cursor stays on the command for editing if
    necessary.

    #+BEGIN_SRC emacs-lisp
      (require 'eshell)
      (require 'em-smart)

      (setq eshell-where-to-jump 'begin)
      (setq eshell-review-quick-commands nil)
      (setq eshell-smart-space-goes-to-end t)
    #+END_SRC

* AucTeX

  [[info:AUCTeX][AUCTeX Manual]]

  Superb handling of TeX documents.

** RefTeX

   [[info:RefTeX][RefTeX Manual]]

   RefTeX provides navigation, easy references, easy citations and
   integrates well into AUCTeX.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
   #+END_SRC

   | Keystroke | Function                           |
   |-----------+------------------------------------|
   | C-c =     | Show TOC and jump to sections      |
   | C-c (     | Insert a label                     |
   | C-c )     | Reference a label                  |
   | C-c [     | Insert a citation (from BibTex db) |
   | C-c <     | Index entry                        |
   | C-c >     | View index                         |
   | C-c &     | View crossref                      |

** Hooks
   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook 'flyspell-mode)
     (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
     (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
     (add-hook 'LaTeX-mode-hook 'orgtbl-mode)
   #+END_SRC

** TeX Settings

   Here are some nice features to have enabled.  Parse-self and
   auto-save will parse the file on load and save
   respectively. Untabify will remove tabs (real ones) before saving.

   I also have a default of =TeX-master= set to =nil=. I used to have
   it set to "master" as recommended in the documentation, but I had
   bad results for LaTeX files generated on the fly.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-auto-untabify t)
     (setq TeX-auto-save t)
     (setq TeX-save-query nil)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)
   #+END_SRC

   For viewing the output, I can specify the command to use on the
   files generated in the process. However, the programs differ on
   GNU/Linux and Windows, so I have differing settings below.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-output-view-style
           (if (eq system-type 'windows-nt)
               (quote
                (("^pdf$" "." "SumatraPDF.exe -reuse-instance %o")
                 ("^html?$" "." "start %o")))
           (quote
            (("^pdf$" "." "evince -f %o")
             ("^html?$" "." "start %o")))))
   #+END_SRC

** XeTeX settings

   To get more beautiful fonts, I use the XeTeX processor. I also
   use this in PDF mode.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-PDF-mode 1)
     (setq TeX-engine 'xetex)
   #+END_SRC

** Preview Settings

   In order for preview to work with ~tikzpicture~ environments, it
   has to be added to the default preamble list.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-packages-alist
                  '("" "tikz" t))

     (setq org-latex-create-formula-image-program 'imagemagick)

     (eval-after-load "preview"
       '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
   #+END_SRC
** DocView

   Have =docview= automatically revert the buffer.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

* Orgmode

  The one feature I cannot do without. Let's set up some features.

** Auto mode

   I add gpg and _archive to the list of known org files. These two
   alternative extensions are for either encrypted org files
   (=.org.gpg=) or for archives (=.org_archive=).

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist
                  '("\\.org\\(.gpg|_archive\\)?$" . org-mode))
   #+END_SRC

** Hooks

   First, I add in a keystroke to toggle the inline images.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
                (lambda ()
                  (local-set-key (kbd "M-i") 'org-toggle-inline-images)))
   #+END_SRC

   The next hook just saves the org files opened before exiting
   emacs -- just in case.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'bnb/kill-emacs-hooks 'org-save-all-org-buffers 'append)
   #+END_SRC


   When I execute =babel= to get graphs from my work logs, I hate
   having to toggle the inline images on/off again.  Here is a hook
   from Rick Frankel to save the day.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-babel-after-execute-hook
               (lambda () (org-display-inline-images nil t)))
   #+END_SRC

** Keys

*** Global

    Some org-mode features are so useful that I need to have them be
    available globally.

     - orgtbl-mode
       Use orgtbl in other modes
     - org-store-link
       Store a link (context-aware) to the current location
     - org-agenda
       Launch the agenda
     - org-capture
       Capture a task/note
     - org-iswitchb
       Switch org buffers
     - visible-mode
       Show the file as-is (no special org handling)
     - org-clock-in/org-clock-out
       Clock in/out of current subtree
     - org-clock-goto
       Go to current/previous clocked task

     #+BEGIN_SRC emacs-lisp
       (bind-key "C-c t" 'orgtbl-mode)
       (global-set-key "\C-cl" 'org-store-link)
       (global-set-key "\C-cr" 'org-capture)
       (global-set-key "\C-cb" 'org-iswitchb)
       (bind-key "<f12>" 'org-agenda)
       (bind-key "<apps>" 'org-agenda)
       (bind-key "<f9> v" 'visible-mode)
       (bind-key "<f9> g" 'org-clock-goto)
       (bind-key "<f9> i" 'org-clock-in)
       (bind-key "<f9> o" 'org-clock-out)
     #+END_SRC

*** Speed

    Using org-mode efficiently for task management is best done with
    speed keys. This are in effect when the cursor is on the first =*=
    of a headline. And they come with an easy cheat-sheet by typing
    =?=. I enable this feature and add some of my own commands.

    #+BEGIN_SRC emacs-lisp
      (setq org-use-speed-commands t)
      (setq org-speed-commands-user (quote (("0" . delete-window)
                            ("1" . delete-other-windows)
                            ("2" . split-window-vertically)
                            ("3" . split-window-horizontally)
                            ("h" . hide-other)
                            ("s" . org-save-all-org-buffers)
                            ("z" . org-add-note)
                            ("N" . org-narrow-to-subtree)
                            ("W" . widen))))
    #+END_SRC

** Org TODO Configuration

   This is the meat of what Org can do. Keeping track of todo items
   with due dates, tags, etc. is really powerful. And I get to
   customize it to suit my needs and my workflow.

*** Keywords

    The keywords that org uses in the headlines exist as sequences
    describing the state changes. The characters in =()= also allow
    fast access to these states described [[info:org#Fast%20access%20to%20TODO%20states][here]].

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                (sequence "WAITING(w@/!)" "SOMEDAY(s!)" "|" "CANCELED(c@/!)")
                (sequence "OPEN(O)" "|" "CLOSED(C)"))))
    #+END_SRC

    Also, the keywords can be specifically colored to help the eye
    infer meaning quickly.

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keyword-faces (quote (("TODO" :foreground "red" :weight bold)
       ("NEXT" :foreground "blue" :weight bold)
       ("DONE" :foreground "forest green" :weight bold)
       ("WAITING" :foreground "yellow" :weight bold)
       ("SOMEDAY" :foreground "goldenrod" :weight bold)
       ("CANCELED" :foreground "orangered" :weight bold)
       ("OPEN" :foreground "magenta" :weight bold)
       ("CLOSED" :foreground "forest green" :weight bold))))
    #+END_SRC

*** Tags

    Org uses tags on headlines for organization. I don't currently
    use them much. I organize mainly by file with a file tag
    specified via [[info:org#In-buffer%20settings][in-buffer settings]] (=#+FILETAGS=).

    However, a global tag list provides a selection list for the
    tagging interface. I use 'project' as my tag to easily
    differentiate simple tasks from more complex ones.

    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '(("PROJECT" . ?p)))
    #+END_SRC

*** Mechanics

    The todo interface allows easy selection of states and triggers
    on certain states to store notes.

    Instead of cycling through states (and possibly triggering log
    entries), I prefer fast entry to jump right to the correct
    state. I also turn off the S-cursor transitions as state
    changes to avoid the logging prompts.

    #+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
    #+END_SRC

    Upon changing the state of todo items, I can automatically
    add/remove tags with the following list. It's a bit lispy, but
    describes what happens upon entry in the specified state. The
    state named as a string has tuples of tags and flags. 't'
    indicates to set the flag, empty means to remove it.

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-state-tags-triggers
            (quote (("CANCELED"
                     ("CANCELED" . t))
                    ("WAITING"
                     ("WAITING" . t))
                    ("SOMEDAY"
                     ("SOMEDAY" . t))
                    (done
                     ("WAITING"))
                    ("TODO"
                     ("WAITING")
                     ("CANCELED"))
                    ("NEXT"
                     ("WAITING"))
                    ("DONE"
                     ("WAITING")
                     ("CANCELED")))))
    #+END_SRC

    Along with tags and states are priorities. I do not use task
    priorities myself so I turn them off.

    #+BEGIN_SRC emacs-lisp
      (setq org-enable-priority-commands nil)
    #+END_SRC

**** Logging

     Org allows logging of states. I turn this on to prompt myself
     for reasons behind specific state changes. There is also a
     setting to set a different drawer for clocking and logs.

     #+BEGIN_SRC emacs-lisp
       (setq org-log-done (quote note))
       (setq org-log-into-drawer t)
       (setq org-drawers '("PROPERTIES" "LOGBOOK" "CLOCK"))
     #+END_SRC

**** Sub-tasks

     Naturally, some tasks are projects composed of smaller
     sub-tasks. Org allows for this as well. I like to enforce the
     dependencies of regular todo items and plain checkbox
     lists. In this way, the overall item cannot change to done
     without the completion of the sub-tasks.

     #+BEGIN_SRC emacs-lisp
       (setq org-enforce-todo-checkbox-dependencies t)
       (setq org-enforce-todo-dependencies t)
     #+END_SRC

     Because of the previous enforcement of state, I can also
     automatically infer when a parent state is complete. The
     following code marks the parent complete once the sub-tasks
     are all done.

     #+BEGIN_SRC emacs-lisp
       (defun org-summary-todo (n-done n-not-done)
         "Switch entry to DONE when all sub-entries are done, to TODO otherwise."
         (let (org-log-done org-log-states)
           (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
       (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
     #+END_SRC

** Capture

   [[info:org#Capture][Capturing]] is crucial to a task system and in this vein, org is no
   slouch. The capture templates define what get captures, where it
   goes, and what the user needs to type.

   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           '(("t" "Todo" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO %?\n  %U\n" :clock-in t :clock-resume t)
             ("r" "todo (Remember location)" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO %?\n  %U\n  %a" :clock-in t :clock-resume t)
             ("n" "Note" entry
              (file "~/Documents/Org/Refile.org")
              "* %?                                                                            :NOTE:\n  %U\n  %a\n  :CLOCK:\n  :END:")
             ("i" "Isabelle Journal" entry (file+datetree "~/Documents/Personal/Org/Isabelle.org")
              "* %?\n\tEntered on %U")
             ("j" "Johannes Journal" entry (file+datetree "~/Documents/Personal/Org/Johannes.org")
              "* %?\n\tEntered on %U")
             ("a" "Andrea Journal" entry (file+datetree "~/Documents/Personal/Org/Andrea.org")
              "* %?\n\tEntered on %U")
             ("e" "Journal" entry (file+datetree "~/Documents/Personal/Org/Journal.org")
              "* %?\n\tEntered on %U")
             ("c" "Capture current TODO mix in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Burndown")
              "%(bnb/org-count-tasks-by-status)")
             ("s" "Capture Weekly Score in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Scores")
              "%(bnb/add-weekly-score-table-entry)")
             ("w" "Weekly Time Table" plain
              (file+function "~/Documents/Org/WeeklyReports.org" bnb/insert-weekly-clocking)
              "%(bnb/insert-weekly-time-sheet)" :unnarrowed t)
             ("o" "org-outlook" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO EMAIL: %:title (%:sender)
       %c

       %?" :clock-in t :clock-resume t)))
   #+END_SRC

   There are five main capture templates here. The first two store a
   todo item in my Refile.org file. The only difference is automatic
   (contextual) link storage in the second case.

   The next item simply stores a note. The next for "Weekly Report"
   is a work in progress. I think that I'll have to either settle
   for a proper datetree or write a custom function.

   The final item is not for direct use, but through the
   =org-protocol= interface and =org-outlook= usage. This lets me
   add a link to an Outlook message on windows. I can then get an
   email at work, mark it to store in emacs and quickly get back to
   the message later.

*** Capture-template helpers for data tables

    These helpers provide functionality used in the capture templates
    above.

    Modifed from [[http://sachachua.com/blog/2014/05/getting-r-ggplot2-work-emacs-org-mode-babel-blocks-also-tracking-number-todos/][Sacha Chua]], this code get the current mix of tasks
    in the agenda files.  I use this as part of my weekly review for
    task amount and mix at a glance.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/org-count-tasks-by-status ()
        (interactive)
        (let ((counts (make-hash-table :test 'equal))
              (today (format-time-string "%Y-%m-%d" (current-time)))
              values output)
          (org-map-entries
           (lambda ()
             (let ((status (elt (org-heading-components) 2)))
               (when status
                 (puthash status (1+ (or (gethash status counts) 0)) counts))))
           "-HOME"
           'agenda)
          (setq values (mapcar (lambda (x)
                                 (or (gethash x counts) 0))
                               '("DONE" "STARTED" "TODO" "WAITING" "CANCELLED" "SOMEDAY")))
          (setq output
                (concat "| " today " | "
                        (mapconcat 'number-to-string values " | ")
                        " | "
                        (number-to-string (apply '+ values))
                        " | "
                        (number-to-string
                         (round (/ (* 100.0 (car values)) (apply '+ values))))
                        "% |"))
          (if (called-interactively-p 'any)
              (insert output)
            output)))
    #+END_SRC

    I also have a helper function to get the score of done tasks
    closed within the last week.  I store this in a table line with
    year and workweek number.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/add-weekly-score-table-entry ()
        (let ((score (apply
                       '+
                       (org-map-entries
                        (lambda ()
                          (string-to-number (or (org-entry-get (point) "Score") "0")))
                        "TODO=\"DONE\"+LEVEL<=2+CLOSED>=\"<-1w>\""
                        'agenda)))
               (year (format-time-string "%Y" (current-time)))
               (ww (number-to-string (bnb/workweek))))
          (format "| %s | %s | %s |" year ww score)))
    #+END_SRC

** Refile

   [[info:org#Refiling%20notes][Refiling notes]] is also spectacular with Org. That is what makes
   it possible for me to simply put every captured item into
   Refile.org and worry about organization later.

   For my setup, I use separate files that hold a singular Tasks
   headline. Because of that, I turn on caching first.

   For the refile targets, I will allow up to 2 levels of search for
   filing in any of the agenda files. For refiling within the current
   file, I set the max to five levels. Anything deeper than six
   levels will exhaust the depth of my thought.

   Finally, I set the filenames to be first for refiling.

   #+BEGIN_SRC emacs-lisp
     (setq org-refile-use-cache t)
     (setq org-refile-targets '((org-agenda-files :maxlevel . 2)
                                (nil :maxlevel . 5)))
     (setq org-refile-use-outline-path 'file)
   #+END_SRC

** Agenda

   Once I have captured and refiled my tasks, I need to remember to
   do them and see what is on the agenda. The ways to view the tasks
   at hand are nicely programmable.

   Some basic settings control small tidbits in the agenda. I turn
   on tags in the agenda line, show the logged items for the day,
   and only show a time grid if a scheduled tasks exists.

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-show-inherited-tags t)

     (setq org-agenda-log-mode-items '(clock))

     (setq org-agenda-clockreport-parameter-plist (quote (:link nil :maxlevel 2 :fileskip0 t)))

     (setq org-agenda-time-grid
           (quote ((daily today require-timed)
               "----------------"
               (800 1000 1200 1400 1600 1800 2000))))
   #+END_SRC

*** Views

    The key to knowing what work there is the agenda views. These
    provide a landscape to list, filter or manipulate
    tasks. =org-agenda-custom-commands= defines which views are
    available by default.

    First, I define a little helper function (from Sacha Chua) to
    display a note with agenda.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/org-agenda-with-tip (arg)
        (org-agenda-list arg)
        (let ((inhibit-read-only t)
              (pos (point)))
          (goto-char (point-max))
          (goto-char pos)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
            (quote (("a" "Agenda" bnb/org-agenda-with-tip)
                    ("w" "Tasks waiting on something" tags "WAITING/!"
                     ((org-use-tag-inheritance nil)
                      (org-agenda-todo-ignore-scheduled nil)
                      (org-agenda-todo-ignore-deadlines nil)
                      (org-agenda-todo-ignore-with-date nil)
                      (org-agenda-overriding-header "Waiting Tasks")))
                    ("r" "Refile New Notes and Tasks" tags "LEVEL=1+REFILE"
                     ((org-agenda-todo-ignore-with-date nil)
                      (org-agenda-todo-ignore-deadlines nil)
                      (org-agenda-todo-ignore-scheduled nil)
                      (org-agenda-overriding-header "Tasks to Refile")))
                    ("n" "Next" tags-todo "-WAITING-CANCELED/!NEXT"
                     ((org-agenda-overriding-header "Next Tasks")))
                    ("A" "Tasks to be Archived" tags "LEVEL=2-REFILE/DONE|CANCELED"
                     ((org-agenda-overriding-header "Tasks to Archive")))
                    ("u" "Upcoming tasks" tags "+SCHEDULED<=\"<+1w>\"-TODO=\"DONE\"|+DEADLINE<=\"<+1w>\"-TODO=\"DONE\""
                     ((org-agenda-overriding-header "Upcoming tasks")))
                    ("U" "Unscheduled tasks" todo "TODO"
                     ((org-agenda-overriding-header "Unscheduled Tasks")
                       (org-agenda-skip-function
                       (lambda nil
                         (org-agenda-skip-entry-if (quote scheduled) (quote deadline))))))
                    ("P" "Printable Agenda" ;tags-todo "-DONE-CANCELED-SOMEDAY"
                     ((tags-todo "+IGNORE"
                                 ((org-agenda-overriding-header "\n== Upcoming Items ==\n")))
                      (agenda "" ((org-agenda-span 14)
                                  (org-agenda-start-on-weekday nil)
                                  (org-agenda-prefix-format "[ ] %T:\t")
                                  (org-agenda-repeating-timestamp-show-all t)
                                  (org-deadline-warning-days 7)))
                      (tags-todo "-DRB-SOMEDAY-REFERENCE-BNBECKWITH"
                                 ((org-agenda-prefix-format "[ ] %T:\t")
                                  (org-agenda-sorting-strategy '(tag-up priority-down))
                                  (org-agenda-todo-keyword-format "")
                                  (org-agenda-todo-ignore-with-date nil)
                                  (org-agenda-todo-ignore-scheduled nil)
                                  (org-agenda-todo-ignore-deadlines nil)
                                  (org-agenda-overriding-header "\nTasks by Context\n------------------\n"))))
                     ((ps-number-of-columns 2)
                      (ps-landscape-mode t)
                      (org-agenda-with-colors nil)
                      (org-agenda-compact-blocks t)
                      (org-agenda-remove-tags t)
                      (ps-paper-type 'a4))
                     ("~/TODO.pdf" "~/TODO.ps"))
                    ("l" "Scoreless" tags-todo "+Score<1"
                     ((org-agenda-todo-ignore-with-date nil)
                      (org-agenda-todo-ignore-scheduled nil)
                      (org-agenda-todo-ignore-deadlines nil)
                      (org-agenda-overriding-header "Scoreless Tasks")))
                    ("h" "Habits" tags "STYLE=\"habit\""
                     ((org-agenda-todo-ignore-with-date nil)
                      (org-agenda-todo-ignore-scheduled nil)
                      (org-agenda-todo-ignore-deadlines nil)
                      (org-agenda-overriding-header "Habits")))
                    ("#" "Stuck Projects" tags-todo "LEVEL=2-REFILE+PROJECT|LEVEL=1+REFILE/!-DONE-CANCELED"
                     ((org-agenda-skip-function 'bh/skip-non-stuck-projects)
                      (org-agenda-overriding-header "Stuck Projects")))
                    ("z" "Agenda (including Personal Files)" agenda ""
                     ((org-agenda-files (list "~/Documents/Personal/Org/"))))
                    ("c" "Select default clocking task" tags "LEVEL=2-REFILE"
                     ((org-agenda-skip-function
                       '(org-agenda-skip-subtree-if 'notregexp "^\\*\\* Organization"))
                      (org-agenda-overriding-header "Set default clocking task with C-u C-u I"))))))
    #+END_SRC

    Phew! That is a lot of lisp! It is easiest to describe each view
    by the key that triggers it.

     - =a= Agenda with tip (keystroke tip)
     - =w= Tasks waiting on something
     - =r= Refile New notes and tasks
     - =n= Next
       Any task with the NEXT tag
     - =A= Tasks ready for Archive
     - =u= Upcoming tasks
       Scheduled or due in the next week.
     - =U= Unscheduled tasks
     - =P= Printable agenda
       Formats tasks at the top with upcoming items below.
     - =S= Scoreless tasks
       Use this to get the scoreless tasks and edit in column mode
     - =h= Habits
     - =#= Stuck projects
     - =z= Agenda with Personal Files
     - =c= Select default clocking task
** Export

   Some global export settings make sense for HTML and \LaTeX


*** HTML

   For HTML, I just want to inline the links to images.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-html-inline-images t)
   #+END_SRC

   I also used to suppress the postamble with
   =org-export-html-postamble=.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-postamble nil)
   #+END_SRC


   I'll use the /fancy/ HTML5 export by default.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-doctype "html5")
     (setq org-html-html5-fancy t)
   #+END_SRC

   I like to have striped tables in email, but this is terribly
   difficult due to cruddy CSS support.  Luckily,
   =org-html-table-row-tags= saves the day and assigns the right
   classes to the table rows.  Now styling can be done in CSS-reduced
   instances.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-table-row-tags
           (cons '(cond (top-row-p "<tr class=\"tr-top\">")
                        (bottom-row-p "<tr class=\"tr-bottom\">")
                        (t (if (= (mod row-number 2) 1)
                               "<tr class=\"tr-odd\">"
                             "<tr class=\"tr-even\">")))
                 "</tr>"))
   #+END_SRC

*** LaTeX

   For \LaTeX, I want to convert fragments to images, and use minted
   for any source blocks. I also want to have =xelatex= as the
   backend.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-latex-listings 'minted)
     (setq org-export-latex-custom-lang-environments
           '((emacs-lisp "common-lispcode")))
     (setq org-export-latex-minted-options '())
     (setq org-latex-to-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   #+END_SRC


   Also, I want to enable some of the other contributed
   exporters. To do this, simply require the files necessary that
   are not on by default.

   I add exporters for Markdown (=ox-md.el=) and beamer
   (=ox-beamer.el=).

   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
     (require 'ox-beamer)
   #+END_SRC

** Clocking

   I have found clocking to be useful in understanding where my time
   goes. And Org makes this easy, fast and painless to do. So very
   nice.

   The clock has some general settings around persistence (resuming
   clocks), history length and resuming a task after clocking in
   twice (interrupted task).

   #+BEGIN_SRC emacs-lisp
     (org-clock-persistence-insinuate)
     (setq org-clock-history-length 28)
     (setq org-clock-in-resume t)
   #+END_SRC

   Behavior of the clock can change to accommodate other needs. I
   like having clocks log into a specific drawer. Also, it is nice
   to remove zero-time clocks and clock out automatically when an
   item completes.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-into-drawer "CLOCK")
     (setq org-clock-out-remove-zero-time-clocks t)
     (setq org-clock-out-when-done t)
   #+END_SRC

   Two settings help resolve most clock issues that I have
   seen. Persisting the clock across sessions helps prevent loss of
   time by accident. Auto-resolution of open clocks help prompt how
   to handle the situation where a dangling clock exists.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-persist 'history)
     (setq org-clock-auto-clock-resolution 'when-no-clock-is-running)
   #+END_SRC

   Two final settings regarding clocking setup how I change and view
   the clocks. I want any clock reports to include the currently
   clocked task as well. And for clock editing, I change to 15
   minute increments.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-report-include-clocking-task t)
     (setq org-time-stamp-rounding-minutes '(1 15))
   #+END_SRC

** Modules

   Org-modules allow for specific functionality within org-mode.

   #+BEGIN_SRC emacs-lisp
     (setq org-modules
           (quote
            (org-bbdb
             org-bibtex
             org-crypt
             org-gnus
             org-id
             org-info
             org-jsinfo
             org-habit
             org-inlinetask
             org-irc
             org-plot
             org-protocol
             org-bookmark
             org-calc)))
   #+END_SRC
*** Org-protocol

    For some reason, I have to load =org-protocol= explicitly in
    order to work.

    #+BEGIN_SRC emacs-lisp
      (require 'org-protocol)
    #+END_SRC

*** Crypt

    Encrypts contents of headlines with =gpg= when saved
    with the "crypt" tag.

    #+BEGIN_SRC emacs-lisp
      (require 'org-crypt)
      (org-crypt-use-before-save-magic)
      (setq org-tags-exclude-from-inheritance (quote ("crypt")))
    #+END_SRC

    The =org-crypt-key= variable will let this use an address from
    the public keyring.

*** Habit

    Some tasks repeat, but you still want to log when you have done
    it. I use this to help me always do my weekly or yearly
    reviews. By including it in =org-modules=, habits get activated.

    My one setting blow sets a width for the graph in Agenda View.

    #+BEGIN_SRC emacs-lisp
      (setq org-habit-graph-column 50)
    #+END_SRC

** Babel

   #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (gnuplot . t)
          (clojure . t)
          (ditaa . t)
          (dot . t)
          (latex . t)
          (python . t)
          (perl . t)
          (R . t)
          (C . t)
          (sqlite . t)
          (plantuml . t)))

       (when (eq system-type 'windows-nt)
         (setq org-babel-R-command "C:/Progra~1/R/R-2.15.1/bin/R --slave --no-save"))
   #+END_SRC

** Miscellaneous Settings
*** Columns

    The default columns are as follows.

    #+BEGIN_SRC emacs-lisp
      (setq org-columns-default-format
            "%80ITEM(Task) %5Score{+} %10Effort(Effort){:} %10CLOCKSUM")
    #+END_SRC

*** Automatically save org files

    I like to save early and often. In earlier versions of orgmode, I
    sometimes had the capture buffer/timer crash on me. So, now I
    save at the top of every hour to be sure.

    #+BEGIN_SRC emacs-lisp
      (run-at-time "00:59" 3600 'org-save-all-org-buffers)
    #+END_SRC

*** File Applications

    This list lets org know how to handle the links of given file
    types. Most things open inside =emacs=, but the others
    set to default rely on the OS to supply a program.

    #+BEGIN_SRC emacs-lisp
      (setq org-file-apps
            (quote ((auto-mode . emacs)
                ("\\.x?html?\\'" . default)
                ("\\.pdf\\'" . default)
                ("\\.mm\\'" . default))))
    #+END_SRC

*** Goto Interface

    By using =C-c C-j=, you can jump easily around a large orgfile
    such as this one. Naturally, the interface you use to do so is
    customizable.

    I explicitly set it to the default because I sometimes go back
    and forth with the default and =outline-path-completion= setting.

    #+BEGIN_SRC emacs-lisp
      (setq org-goto-interface 'outline-path)
    #+END_SRC

*** Special Control Keys

    Orgmode has a different idea of some of the default emacs
    commands to make it easier to work with the structures involved.

    For =C-a= or =C-e= within a headline, it will only try to
    navigate the headline text the first time. Additional keypresses
    will move to the true beginning/ending of lines.

    =C-k= also can behave specially in headlines depending on its
    location. When point is at the beginning, it will kill the
    headline and the folded subtree below. In the middle of a
    headline, it kills the headline text up to the tags. After the
    headline text, it kills the tags.

    #+BEGIN_SRC emacs-lisp
      (setq org-special-ctrl-a/e t)
      (setq org-special-ctrl-k t)
    #+END_SRC

*** Auto-revert mode

    If the org files are under DVCS like git, then the edits may
    happen while open in emacs.

    This is a global setting, but most useful for the org files that
    exists elsewhere.

    #+BEGIN_SRC emacs-lisp
      (setq global-auto-revert-mode t)
    #+END_SRC

*** IDO Integration

    IDO integrates well into orgmode. Anytime completion is
    necessary, I like to use the IDO mechanics.

    The =outline-path-completion= may conflict with IDO, so then it
    is best to have it not use IDO in this case.

    #+BEGIN_SRC emacs-lisp
      (setq org-completion-use-ido t)
      (setq org-outline-path-complete-in-steps nil)
    #+END_SRC

*** Display settings

    There are a collection of settings that define how the
    headlines, subtrees, and notes render.

    For the headline stars, there are two settings of note. I am
    explicit that I do *not* want only odd levels. I also like to
    hide the leading stars.

    #+BEGIN_SRC emacs-lisp
      (setq org-odd-levels-only nil)
      (setq org-hide-leading-stars nil)
    #+END_SRC

    Cycling the headline states can produce different views of the
    files. I like this to be as compact as possible, so I try to
    squash the lines between the collapsed trees. There is also a
    flag to open a file collapsed. This I like too -- I get a
    compact view of the file and can jump to a relevant section with
    =C-c C-j=.

    #+BEGIN_SRC emacs-lisp
      (setq org-cycle-separator-lines 0)
      (setq org-startup-folded 'content)
    #+END_SRC

    When using SRC-blocks, org can provide highlighting native to
    the SRC type. Note that this may slow down some files.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
    #+END_SRC

*** Insertion

     I define when org should leave a blank line before an
     item. In my case, it is headings and plain list items.

    #+BEGIN_SRC emacs-lisp
      (setq org-blank-before-new-entry '((heading)
                                         (plain-list-item)))
    #+END_SRC

     Also, when inserting a new heading, do so after the current
     subtree.

    #+BEGIN_SRC emacs-lisp
      (setq org-insert-heading-respect-content t)
    #+END_SRC

*** Properties

    #+BEGIN_SRC emacs-lisp
      (setq org-global-properties (quote (("STYLE_ALL" . "habit")
                          ("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00")
                          ("Score_ALL" . "10 5 2 1"))))
    #+END_SRC

** Org-drill

   #+BEGIN_SRC emacs-lisp
     (require 'org-drill)
   #+END_SRC

* Elisp Extras

** Google

   #+BEGIN_SRC emacs-lisp
     (defun google ()
       "Google the selected region if any, display a query prompt otherwise."
       (interactive)
       (browse-url
        (concat
         "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
         (url-hexify-string (if mark-active
              (buffer-substring (region-beginning) (region-end))
            (read-string "Google: "))))))
   #+END_SRC

** Auto-display agenda

    From
    http://lists.gnu.org/archive/html/emacs-orgmode/2010-03/msg00367.html,
    John Weigley shows a way to display the agenda after some period
    of inactivity.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/jump-to-org-agenda ()
       (interactive)
       (let ((buf (get-buffer "*Org Agenda*"))
             wind)
         (if buf
             (if (setq wind (get-buffer-window buf))
                 (select-window wind)
               (if (called-interactively-p)
                   (progn
                     (select-window (display-buffer buf t t))
                     (org-fit-window-to-buffer))
                 (with-selected-window (display-buffer buf)
                   (org-fit-window-to-buffer))))
            (bnb/org-agenda-with-tip nil))))

     (defun bnb/idle-agenda (&optional arg)
       (interactive "P")
       (setq bnb/iagenda
             (if arg
                 (cancel-timer bnb/iagenda)
               (run-with-idle-timer 3600 t 'bnb/jump-to-org-agenda))))

     (when (eq system-type 'windows-nt)
       (bnb/idle-agenda))
   #+END_SRC

    The when clause at the end is because I primarily keep my agenda
    information on Windows. No need to have my agenda open on the
    different GNU/Linux boxes all the time.

* Server

   [[info:emacs#Emacs%20Server][Using Emacs as a server]] is a great way to keep the power
   responsive.

  #+BEGIN_SRC emacs-lisp
    (server-start)
  #+END_SRC

   I need to look into the TCP connections to see how
   that work across machines. Perhaps it can be useful in a
   multi-machine work environment.

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (load-file custom-file)
  #+END_SRC

* Local customizations (user-login-name)

  I also intend to have a generic call to an installed local file
  that may need to behave differently from =custom.el=. This loads
  last so that it can modify any existing setting made here to work
  on the specific system in question.

  In the code below, I add =~/.emacs.d/= to the load path and have a
  protected call to =load-library=.  If the file exists, it gets
  loaded, otherwise the error normally returned if the file is
  non-existant gets ignored.

  #+BEGIN_SRC emacs-lisp
    (condition-case err
        (progn
          (load-file (format "~/.emacs.d/%s.el"  user-login-name))
          (message "Loaded local settings file %s.el" user-login-name))
      (file-error
       (message "Skipping %s library as it does not exist." user-login-name))
      nil)
  #+END_SRC


