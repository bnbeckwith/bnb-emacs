#+TITLE: BNBECKWITH Tangled Emacs Initialization
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:t html-style:t
#+OPTIONS: html5-fancy:nil tex:t
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.7a)
#+SETUPFILE: theme-readtheorg.setup
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: xhtml-strict
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+INFOJS_OPT:
#+LATEX_HEADER:
#+PROPERTY: header-args:emacs-lisp :results silent

This document tangles (in literate programming style) the necessary
commands to initialize Emacs to my liking and the documentation for my
choices.

To clone, go to the [[http://github.com/bnbeckwith/bnb-emacs][github repository]]. For a pretty view, head over to
the [[http://bnbeckwith.github.com/bnb-emacs][generated page]].

* Installation

  My =init.el= file is quite simple and is generated by the following
  block. Essentially, I just have to install this package
  (=bnb-emacs=) in the =~/.emacs.d/= directory and run the code block
  (=C-c C-c=) to bootstrap the system.

  #+BEGIN_SRC emacs-lisp :tangle "~/.emacs.d/init.el" :exports code :results silent
    ;;; init.el --- bnbeckwith config -*- eval: (read-only-mode 1) -*-
    (require 'package)
    (setq package-enable-at-startup nil)
    (package-initialize)

    (require 'ob-tangle)
    (org-babel-load-file "~/.emacs.d/bnb-emacs/Readme.org")
  #+END_SRC

  The bootstrapping is simple. Emacs finds =~/.emacs.d/init.el= and
  runs the code. The first step is to initialize the packages I have
  installed via ELPA and others. This is very cool

  Next, I load =ob-tangle= (part of =org-mode=). Then
  ~org-babel-load-file~ extracts the emacs-lisp code blocks in this
  document and loads the resulting =Readme.org=.

  As I add packages or lines to this document, my initialization is
  already in place and ready to go.

* Notes

  This section has specific notes that are relevant to my emacs setup
  in general and this document in particular.

** Emacs Build

   My current flavor of Emacs comes from:
   https://github.com/d12frosted/homebrew-emacs-plus

** Pending sections

   There are some features that I like to take on a /trial run/. These
   are marked with the *PENDING* tag to help me remember and evaluate.

** Performance

   #+BEGIN_SRC emacs-lisp
     (setq use-package-verbose t
           use-package-minimum-reported-time 0)
   #+END_SRC

* Personal Information

  The full name is used for email messages.

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Benjamin Beckwith")
  #+END_SRC

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine. This keeps the setup the same and allows for
   only some details to differ.

   I like to set the custom file explicitly. Mine resides in the
   =~/.emacs.d/= directory. This code block loads it if it exists.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (if (file-exists-p custom-file)
        (load-file custom-file))

    (bind-key "<f7>"
  	    (lambda ()
  	      (interactive
  	       (find-file custom-file))))
  #+END_SRC

  If the file doesn't exist, =Emacs= will still use the file if any
  changes are made through the /custom interface/.

  Sometimes I'll get bad settings or cruft in that file. I now have a
  key, ~<F7>~, for easy navigation to wherever the =custom-file= points.

* Small Settings

  The next sections encompass some small settings to make Emacs mine
  (and maybe yours). There is a loose order of dependency, but even
  then it isn't strict.

** Path

   Sometimes Emacs' idea of path differs from the shell. The package
   =exec-path-from-shell= seeks to bring those in line with each other.

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** Backups

   Sensible backup settings from [[https://www.emacswiki.org/emacs/BackupDirectory]]

   #+BEGIN_SRC emacs-lisp
     (setq backup-by-copying t
           create-lockfiles nil
           backup-directory-alist '((".*" . "~/.saves"))
           ;; auto-save-file-name-transforms `((".*" "~/.saves" t))
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC

   Here's a quick rundown of the settings:

   - [[elisp:(describe-variable%20'backup-by-copying)][~backup-by-copying~]] :: Use copying to create backups when ~t~
   - [[elisp:(describe-variable 'create-lockfile)][~create-lockfiles~]] :: Don't use lockfiles if ~nil~
   - [[elisp:(describe-variable%20'backup-directory-alist)][~backup-directory-alist~]] :: List of regexp/location pairs of where to backup files
   - [[elisp:(describe-variable%20'auto-save-file-name-transforms)][~auto-save-file-name-transforms~]] :: Transform file names before autosave
   - [[elisp:(describe-variable%20'delete-old-versions)][~delete-old-versions~]] :: Delete excess backups silently if ~t~
   - [[elisp:(describe-variable%20'kept-new-versions)][~kept-new-versions~]] :: Number of newest versions to keep
   - [[elisp:(describe-variable%20'kept-old-versions)][~kept-old-versions~]] :: Number of oldest versions to keep
   - [[elisp:(describe-variable%20'version-control)][~version-control~]] :: When ~t~, make numeric backup versions always

** Super keys

   I like to be able to use the command (or super or hyper) keys for
   shortcuts. I need to take care to not interfere with the
   built-in shortcuts or my bindings will not work.

   #+BEGIN_SRC emacs-lisp
     (setq mac-function-modifier 'hyper
           mac-pass-command-to-system nil
           mac-right-option-modifier 'none
           mac-right-command-modifier 'none
           mac-right-control-modifier 'hyper
           mac-command-modifier 'meta
           mac-control-modifier 'ctrl
           mac-option-modifier 'super)
   #+END_SRC

   Note that the right =option= and =command= keys will pass through
   to the system. This is especially cool for the =option= key on a
   mac that lets insert special characters directly. (E.g. á or ∑ or
   ®)

   Inspiration for the keys comes from [[https://www.wisdomandwonder.com/article/10146/every-emacser-can-use-hyper-on-every-usb-hid-keyboard][wisdom and wonder]].

** Package archives

   I like to pull from the popular list of package archives.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     (add-to-list 'package-archives '("sr" . "http://joseito.republika.pl/sunrise-commander/") t)
   #+END_SRC

   I install the packages with these repositories. This may
   take some time the first time it runs.

   Org-mode has their own repositories that keep me on the bleeding
   edge. They is why that repository is listed separately above.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (setq use-package-verbose t
           use-package-always-ensure t)
     (require 'use-package)
   #+END_SRC

*** From Source

    [[https://github.com/quelpa/quelpa][Quelpa]] grabs and builds packages from source (e.g. Github). I have
    found a few things not in any package archive yet that I'd like to
    have automatically installed.

    Along with the ~quelpa~ package, ~quelpa-use-package~ adds a
    handler to ~use-package~ making it fit in nicely with the rest of
    my configuration.

    #+BEGIN_SRC emacs-lisp
      (use-package quelpa)
      (use-package quelpa-use-package)

      ;; Handle the `use-package-always-ensure' setting
      (quelpa-use-package-activate-advice)
    #+END_SRC

*** Load the latest files

    Always pick the latest version of the library to load.

    #+BEGIN_SRC emacs-lisp
      (setq load-prefer-newer t)
    #+END_SRC

** Binding Keys

   For binding keys, I use the =bind-key= package. Not only does it
   easily bind keys, but it does so with some nice features.

   #+BEGIN_SRC emacs-lisp
     (use-package bind-key
       :bind ("C-h B" . describe-personal-keybindings))
   #+END_SRC

   By using ~bind-key~, you can specify the keystrokes that invoke a
   command. This is regular behavior that you can already achieve in
   Emacs and will result in a global binding.

   If you also want to override any possible minor-mode bindings of
   the same keys, you can use ~bind-key*~ instead.

   There is also an ~unbind-key~ to, of course, remove any binding.

   The real kicker is that it will keep track of these bindings and
   let you see a summary of your customizations with

   : M-x describe-personal-keybindings

   This is bound to ~C-h B~ above.

** Hydra

   Sometimes it is useful to go into a /command mode/ that lets you
   quickly do a few different actions. Hydra does that and more.

   By defining specific /hydras/, you can group together commands with
   documentation. Think of it as a mini-control-panel. I include it here and
   use it elsewhere when grouping commands. (See [[Toggle Map]] for an example)

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t)
   #+END_SRC

** Personal Keymaps

   These are inspired from
   [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html]].

*** Toggle Map

    This toggle map shows the current /toggleable/ settings with
    shortcut keys for enabling. The amaranth color makes this buffer
    stay around until I press =q=.

    #+BEGIN_SRC emacs-lisp
      (defmacro toggle-setting-string (setting)
        `(if (and (boundp ',setting) ,setting) '[x] '[_]))

      (bind-key
       "C-x t"
       (defhydra hydra-toggle (:color amaranth)
         "
      _c_ column-number : %(toggle-setting-string column-number-mode)  _b_ orgtbl-mode    : %(toggle-setting-string orgtbl-mode)  _x_/_X_ trans          : %(identity bnb/transparency)
      _e_ debug-on-error: %(toggle-setting-string debug-on-error)  _s_ orgstruct-mode : %(toggle-setting-string orgstruct-mode)  _m_   hide mode-line : %(toggle-setting-string bnb/hide-mode-line-mode)  
      _u_ debug-on-quit : %(toggle-setting-string debug-on-quit)  _h_ diff-hl-mode   : %(toggle-setting-string diff-hl-mode)
      _f_ auto-fill     : %(toggle-setting-string auto-fill-function)  _B_ battery-mode   : %(toggle-setting-string display-battery-mode)
      _t_ truncate-lines: %(toggle-setting-string truncate-lines)  _l_ highlight-line : %(toggle-setting-string hl-line-mode)
      _r_ read-only     : %(toggle-setting-string buffer-read-only)  _n_ line-numbers   : %(toggle-setting-string linum-mode)
      _w_ whitespace    : %(toggle-setting-string whitespace-mode)  _N_ relative lines : %(if (eq linum-format 'linum-relative) '[x] '[_])
      "
         ("c" column-number-mode nil)
         ("e" toggle-debug-on-error nil)
         ("u" toggle-debug-on-quit nil)
         ("f" auto-fill-mode nil)
         ("t" toggle-truncate-lines nil)
         ("r" dired-toggle-read-only nil)
         ("w" whitespace-mode nil)
         ("b" orgtbl-mode nil)
         ("s" orgstruct-mode nil)
         ("x" bnb/transparency-next nil)
         ("B" display-battery-mode nil)
         ("X" bnb/transparency-previous nil)
         ("h" diff-hl-mode nil)
         ("l" hl-line-mode nil)
         ("n" linum-mode nil)
         ("N" linum-relative-toggle nil)
         ("m" bnb/hide-mode-line-mode nil)
         ("q" nil)))
    #+END_SRC

*** Elisp Maps

    Here are some nice-to-have features when in /elisp-mode/.

    #+BEGIN_SRC emacs-lisp
      (bind-key
       "C-c e"
       (defhydra hydra-elisp-cmds (:color blue)
         ("b" eval-buffer "eval buffer")
         ("e" toggle-debug-on-error "debug-on-error")
         ("f" emacs-lisp-byte-compile-and-load "byte-compile-and-load")
         ("r" eval-region "eval-region")
         ("q" nil))
       emacs-lisp-mode-map)
    #+END_SRC

    There is one block for execuing items and another for looking up
    specific =elisp= help.

    #+BEGIN_SRC emacs-lisp
      (bind-key
       "C-h e"
       (defhydra hydra-elisp-help (:color blue)
         ("e" view-echo-area-messages "view-echod-area-messages")
         ("f" find-function "find-function")
         ("k" find-function-on-key "find-function-on-key")
         ("l" find-library "find-library")
         ("v" find-variable "find-variable")
         ("V" apropos-value "apropos-value")
         ("i" info-display-manual "info-display-manual")
         ("q" nil))
       emacs-lisp-mode-map)
    #+END_SRC

*** Small bindings

    This sections contains smaller bindings (or overrides) that I use
    to customize functionality.

**** Whitespace deletion

     By default, ~M-\~ performs =delete-horizontal-space= and will
     consume all of the whitespace present.

     I'd like it to be smart and leave one or no spaces if
     possible. The =fixup-whitespace= function will do that.

     #+BEGIN_SRC emacs-lisp
       (bind-key "M-\\" 'fixup-whitespace)
     #+END_SRC

**** Scroll window up/down

     In addition to moving the cursor, it is also interesting to
     scroll the screen (without moving the cursor with respect to the
     frame).

     #+BEGIN_SRC emacs-lisp
       (defun bnb/scroll-up-1 ()
         (interactive)
         (cua-scroll-up 1))

       (defun bnb/scroll-down-1 ()
         (interactive)
         (cua-scroll-down 1))

       (bind-keys
        ("M-n" . bnb/scroll-up-1)
        ("M-p" . bnb/scroll-down-1))
     #+END_SRC

**** Align Regexp

     When selecting a region, a quick trip to ~align-regexp~ can align
     all of that nasty text.

     #+BEGIN_SRC emacs-lisp
       (bind-key "C-c TAB" 'align-regexp)
     #+END_SRC

*** Kill current buffer

    Another great tip from [[http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/][Pragmatic Emacs]], use ~kill-this-buffer~ to
    kill the current buffer instead of asking which one.  I'm not
    overriding the =C-x k= default, but added a =C-x C-k= alternative.

    #+BEGIN_SRC emacs-lisp
      (bind-keys
       ("C-x C-k" . kill-this-buffer))
    #+END_SRC

** Minibuffer History

   Let's get rid of duplicates in the minibuffer history.

   #+BEGIN_SRC emacs-lisp
     (setq history-delete-duplicates t)
   #+END_SRC

   This saves the minibuffer histories to preserve across emacs
   sessions.

   #+BEGIN_SRC emacs-lisp
     (setq savehist-additional-variables
           '(search-ring regexp-search-ring)
           savehist-file "~/.emacs.d/savehist")
     (savehist-mode t)
   #+END_SRC

** Abbrev

   The following block is courtesy of [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]].

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-i" 'bnb/ispell-word-then-abbrev)

     (defun bnb/ispell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction
     made. With prefix P, create local abbrev. Otherwise, it will be
     global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft))))

     (setq save-abbrevs t)
     (setq-default abbrev-mode t)
     (diminish 'abbrev-mode)
   #+END_SRC

** Hippie Expand

   Try to expand the text before point in an intelligent way. Repeat
   the keypress to cycle through options.

   #+BEGIN_SRC emacs-lisp
     (bind-key "M-/" 'hippie-expand)
   #+END_SRC

** Emacs Bookmarks

   [[http://emacswiki.org/emacs/BookMarks]]

   | Keystroke             | Action                  |
   |-----------------------+-------------------------|
   | =C-x r m=             | Set a bookmark          |
   | =C-x r b=             | Jump to a bookmark      |
   | =C-x r l=             | List your bookmarks     |
   | =M-x bookmark-delete= | Delete bookmark by name |

   I will auto-save my bookmarks.

   #+BEGIN_SRC emacs-lisp
     (setq bookmark-save-flag t)
   #+END_SRC

** Writegood Mode

   This mode installs through the ELPA system.

   #+BEGIN_SRC emacs-lisp
     (use-package writegood-mode
       :ensure t
       :bind
       ("C-c g"     . writegood-mode)
       ("C-c C-g g" . writegood-grade-level)
       ("C-c C-g e" . writegood-reading-ease))
   #+END_SRC

** Spell Checking

   [[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][This site]] has an interesting suggestion on how to use =aspell= for
   CamelCase spell checking.

   #+BEGIN_SRC emacs-lisp
     (cond
      ((executable-find "/usr/local/bin/aspell")
       (setq ispell-program-name (executable-find "aspell")
             ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")))
      (t (setq ispell-program-name nil)
         (message "No aspell found!")))
   #+END_SRC

** Proselint

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load "flycheck-mode"
       (flycheck-define-checker proselint
         "A linter for prose"
         :command ("proselint" source-inplace)
         :error-patterns
         ((warning line-start (file-name) ":" line ":" column ": "
                   (id (one-or-more (not (any " "))))
                   (message (one-or-more not-newline)
                            (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                   line-end))
         :modes (text-mode markdown-mode gfm-mode org-mode))
       (add-to-list 'flycheck-checkers 'proselint))
   #+END_SRC

** Development

   For any lisp development, the following is nice to have.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
   #+END_SRC

   While developing, documentation is nice to have handy and
   automatic.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'cperl-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'eshell-mode-hook 'turn-on-eldoc-mode)
   #+END_SRC

** Encryption

   [[info:epa#Top][EasyPG Assistant]] helps with integration of GnuPG.  The command
   below turns on the automatic encryption/decryption of =*.gpg=
   files.

   #+BEGIN_SRC emacs-lisp
     (use-package epa
       :disabled t
       :config (epa-file-enable))
   #+END_SRC

   It is possible that you would need to [[elisp:(customize-group%20'epg)][customize the location of
   gpg]].

** Read-only helpers

   For read-only files, look at them in =view-mode= which will enable
   vi-style navigation.

   #+BEGIN_SRC emacs-lisp
     (use-package view
       :init (setq view-read-only t)
       :bind (:map view-mode-map
   		("n" . next-line    )
   		("p" . previous-line)
   		("j" . next-line    )
   		("k" . previous-line)
   		("l" . forward-char)
   		("h" . bnb/view/h)
   		("q" . bnb/view/q))
       :config
       (defun bnb/view/h ()
         (interactive)
         (forward-char -1))
       (defun bnb/view/q ()
         (interactive)
         (view-mode -1)))
   #+END_SRC

** Default File encoding

   I like to have the files be =utf-8= by default. Do
   let me know if I shouldn't do this, will you?

   Set =utf-8= for all coding systems except for the clipboard on
   windows. That one gets =utf-16le= to be compatible.

   #+BEGIN_SRC emacs-lisp
     (prefer-coding-system       'utf-8)
     (set-default-coding-systems 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-language-environment 'utf-8)
     (setq buffer-file-coding-system 'utf-8
           x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
     ;; MS Windows clipboard is UTF-16LE
     (when (eq system-type 'windows-nt)
       (set-clipboard-coding-system 'utf-16le-dos))
   #+END_SRC

** Vimrc generic mode

   Good to have to help with my pentadactyl configuration as it is in
   a vim-style of configuration.

   #+BEGIN_SRC emacs-lisp
     (define-generic-mode 'vimrc-generic-mode
       '()
       '()
       '(("^[\t ]*:?\\(!\\|ab\\|map\\|unmap\\)[^\r\n\"]*\"[^\r\n\"]*\\(\"[^\r\n\"]*\"[^\r\n\"]*\\)*$"
          (0 font-lock-warning-face))
         ("\\(^\\|[\t ]\\)\\(\".*\\)$"
          (2 font-lock-comment-face))
         ("\"\\([^\n\r\"\\]\\|\\.\\)*\""
          (0 font-lock-string-face)))
       '("/vimrc\\'" "\\.vim\\(rc\\)?\\'")
       '((lambda ()
           (modify-syntax-entry ?\" ".")))
       "Generic mode for Vim configuration files.")
   #+END_SRC

** Ediff single frame

   I really dislike the multi-frame mode of =ediff=.  It is confusing
   to use and really messes up my [[http://dwm.suckless.org][dwm]] usage. By explicitly setting
   the following setting, it forces =ediff= to use only one
   frame.

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC

   Now the control window will be a small window instead of a
   separate frame.

** Git
*** Magit

    [[info:magit#Top][Magit]] is a git interface for Emacs.

    Here I set a global key for ~magit-status~. Think 'G' looks
    like 6.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :bind ("<f6>" . magit-status)
        :config
        (setq magit-last-seen-setup-instructions "1.4.0"))
    #+END_SRC

**** Release 1.4.0

     This magit release warns about auto-revert of buffers.  This is
     turned on by default and I will keep that setting.  To turn off
     the magit warning, I set =magit-last-seen-setup-instructions= to
     1.4.0 as shown above.

**** Magithub

     Add in an interface to Github

     #+BEGIN_SRC emacs-lisp
       (use-package magithub
         :ensure t
         :after magit
         :config (magithub-feature-autoinject t))
     #+END_SRC

*** Git timemachine                                                 :PENDING:

    Loop through the history of a file with some simple keystrokes (or wheeling up and down)

    #+BEGIN_SRC emacs-lisp
      (use-package git-timemachine
        :ensure t
        :bind ("C-x C-g" . git-timemachine-toggle)
        :config
        (bind-keys
         :map git-timemachine-mode-map
         ("<M-up>" . git-timemachine-show-previous-revision)
         ("<M-down>" . git-timemachine-show-next-revision)
         ("<S-wheel-up>" . git-timemachine-show-previous-revision)
         ("<S-wheel-down>" . git-timemachine-show-next-revision)))
    #+END_SRC

*** Smerge

    Somewhere along the line, =smerge= was added. To facilitate
    editing merge conflicts, this hydra helps me do the work.

    #+BEGIN_SRC emacs-lisp
      (add-hook
       'smerge-mode
       (lambda ()
         (bind-key
          "C-c ^ h"
          (defhydra hydra-smerge (:color amaranth)
            ("a" smerge-keep-all "Keep all")
            ("b" smerge-keep-base "Keep base")
            ("m" smerge-keep-mine "Keep mine")
            ("o" smerge-keep-other "Keep other")
            ("n" smerge-next "Next conflict")
            ("p" smerge-previous "Previous conflict")
            ("r" smerge-resolve "Keep mine")
            ("q" nil "quit"))
          smerge-mode-map)))
    #+END_SRC

** Open/Edit This file

   When I hit ~<F5>~, open this file for editing. That way, any
   time I have something I need to remember for my emacs setting, it
   is just a button-push away.

   #+BEGIN_SRC emacs-lisp
     (bind-key "<f5>"
               (lambda ()
                 (interactive)
                 (find-file "~/.emacs.d/bnb-emacs/Readme.org")))
   #+END_SRC

** Sounds

   I dislike the bell ringing when I hit =C-g=. To silence the bell,
   just set the =ring-bell-function= to =nil=.

   #+BEGIN_SRC emacs-lisp
     (setq visual-bell nil
           ring-bell-function `(lambda () nil))
   #+END_SRC

** Midnight Mode

   This mode looks at midnight and kills any inactive buffers. By
   default, /inactive/ means is any buffer untouched for three days.

   #+BEGIN_SRC emacs-lisp
     (use-package midnight)
   #+END_SRC

** Which Key

   This [[https://github.com/justbur/emacs-which-key][helpful little package]] makes it easy to remember emacs
   prefixed commands.  Start typing a prefix such as =C-x= after a
   brief delay, the options for any following commands are shown.

   I am using a setup that tries the right side of emacs first, and
   punts to a bottom window if there is not enough room.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :diminish which-key-mode
       :init
       (which-key-mode)
       (which-key-setup-side-window-right-bottom)
       (setq which-key-max-description-length 60))
   #+END_SRC

** Ace Utilities
*** Ace Flyspell

    Turn on [[https://github.com/cute-jumper/ace-flyspell][ace-flyspell]] when flyspell is enabled.
    
    #+BEGIN_SRC emacs-lisp
      (use-package ace-flyspell
        :ensure t
        :commands (ace-flyspell-setup)
        :init
        (add-hook 'flyspell-mode-hook 'ace-flyspell-setup))
    #+END_SRC


*** Ace Isearch                                                     :PENDING:

    Supercharge ~isearch~ to vary its behavior depending on the
    input. The ~C-'~ key let's me jump to the isearch match easily
    with the ~ace-jump~ methods.

    #+BEGIN_SRC emacs-lisp
      (use-package ace-isearch
        :ensure t
        :bind (:map isearch-mode-map
                    ("C-'" . ace-isearch-jump-during-isearch))
        :diminish ace-isearch-mode
        :config
        (global-ace-isearch-mode t)
        (defun bnb/ace-swiper-from-isearch  ()
        "Invoke `swiper' from ace-isearch."
        (interactive)
        (let (($query (if isearch-regexp
                          isearch-string
                        (regexp-quote isearch-string))))
          (let (search-nonincremental-instead)
            (ignore-errors (isearch-exit)))
          (swiper $query)))
        (setq ace-isearch-function-from-isearch 'bnb/ace-swiper-from-isearch
              ace-isearch-input-length 8))
    #+END_SRC

*** Ace Link

    In modes with links, use =o= to jump to links. Map =M-o= to do the
    same in ~org-mode~.

    #+BEGIN_SRC emacs-lisp
      (use-package ace-link
        :ensure t
        :bind (:map org-mode-map
                   ("M-o" . ace-link-org))
        :config (ace-link-setup-default))
    #+END_SRC

*** Ace Window

    Instead of =C-x o= traversal, =ace-window= mode provides numbers
    for quick window access

    Set the keys to something other than the default numbers. Note
    that this also limits the number of windows that can be used, but
    given my usage, I doubt it goes up to 'j' often.

    Also, I modify the face attribute to make the window numbers large.

    After reading [[https://github.com/abo-abo/ace-window/wiki][the wiki]], I supercharged the interface for =ace-window=.

    #+BEGIN_SRC emacs-lisp
      (use-package ace-window
        :ensure t
        :bind
        ("H-a"    . ace-window)
        ("<f9> a" . ace-window)
        :config
        (setq aw-keys '(?j ?k ?l ?\; ?n ?m)
              aw-leading-char-style 'path
              aw-dispatch-always t
              aw-dispatch-alist
              '((?x aw-delete-window "Ace - Delete Window")
                (?c aw-swap-window   "Ace - Swap window")
                (?n aw-flip-window   "Ace - Flip window")
                (?v aw-split-window-vert "Ace - Split Vert Window")
                (?h aw-split-window-horz "Ace - Split Horz Window")
                (?m delete-other-windows "Ace - Maximize Window")
                (?b balance-windows)))

        (defhydra hydra-window-size (:color amaranth)
          "Window size"
          ("h" shrink-window-horizontally "shrink horizontal")
          ("j" shrink-window "shrink vertical")
          ("k" enlarge-window "enlarge vertical")
          ("l" enlarge-window-horizontally "enlarge horizontal")
          ("q" nil "quit"))
        (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)

        (defhydra hydra-window-frame (:color red)
          "Frame"
          ("f" make-frame "new frame")
          ("x" delete-frame "delete frame")
          ("q" nil "quit"))
        (add-to-list 'aw-dispatch-alist '(?\; hydra-window-frame/body) t)

        (defhydra hydra-window-scroll (:color amaranth)
          "Scroll other window"
          ("n" scroll-other-window "scroll")
          ("p" scroll-other-window-down "scroll down")
          ("q" nil "quit"))
        (add-to-list 'aw-dispatch-alist '(?o hydra-window-scroll/body) t)

        (set-face-attribute 'aw-leading-char-face nil :height 2.0))
    #+END_SRC

*** Avy Goto

    It is time to make some shortcuts for jumping to see if they make
    sense for me.  The interesting feature that I can use is that
    these highlight text an all shown buffers.

    #+BEGIN_SRC emacs-lisp
      (use-package avy
        :ensure t
        :bind
        ("H-SPC" . avy-goto-char-timer)
        ("H-w"   . avy-goto-word-1)
        ("H-c"   . avy-goto-char-2)
        ("H-l"   . avy-goto-line)
        ("H-d"   . avy-goto-word-0)
        ("<f9> SPC" . avy-goto-char-timer)
        ("C-c g" . avy-goto-word-1)
        ("M-g l" . avy-goto-line)
        ("M-g c" . avy-goto-char-2)
        ("M-g w" . avy-goto-word-0))
    #+END_SRC

    The commands begin with the normal prefix of =M-g= for the goto
    commands and use l,c and w for lines, characters and words
    respectively.

    The char version I use here is the two-element version. For
    single character jumping, I have the Ace Isearch mode below that
    will facilitate quick jumping.

*** Avy Zap

    Zap to char using avy.

    #+BEGIN_SRC emacs-lisp
      (use-package avy-zap
        :ensure t
        :bind ("M-z" . avy-zap-to-char-dwim)
        ("M-Z" . avy-zap-up-to-char-dwim))
    #+END_SRC

** Edit Server

   The edit server talks to Chrome and uses emacs to edit any
   text areas. I start this server here.

   #+BEGIN_SRC emacs-lisp
     (use-package edit-server
       :ensure t
       :defer 10
       :init
       (edit-server-start))
   #+END_SRC

   Chrome needs to have the proper extension installed there too for
   the installation to be complete.

** Regexp-Builder

   Emacs regular expressions are not the easiest to use out of the
   box. Emacs now has [[help:re-builder][regexp-builder]] to assist you in building the
   correct regexp as you type.

   However, to complicate matters, there are five different /syntaxes/
   of regular expression that the builder can use. The =string=
   syntax is what I tend to use most in searching and replacing, so I
   will make that my default.

   #+BEGIN_SRC emacs-lisp
     (setq reb-re-syntax 'string)
   #+END_SRC

   | Key Binding | Meaning                                    |
   |-------------+--------------------------------------------|
   | =C-c TAB=   | Switch syntax                              |
   | =C-c C-e=   | Sub-expression mode (show matching groups) |
   | =C-c C-s/r= | Search forward/backward                    |
   | =C-c C-w=   | Copy regexp to kill ring                   |
   | =C-c C-q=   | Quit the builder                           |

   Be sure to consult the [[info:emacs#Regexps][syntax of regular expressions]] to learn more
   about the weird backslashing.

** IBuffer

   Use ~ibuffer~ instead of ~list-buffers~ for buffer management. The
   most visible difference being the coloring that ~ibuffer~ uses.

   I also squash any empty groups from being displayed and add hooks
   to automatically set the filter groups and update contents.

   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-b" 'ibuffer)

     (setq ibuffer-show-empty-filter-groups nil)

     (add-hook 'ibuffer-mode-hook
               '(lambda ()
                  (ibuffer-auto-mode 1)
                  (ibuffer-switch-to-saved-filter-groups "Standard")))
   #+END_SRC

*** Groups

    The buffer list splits into arbitrary groups for easier
    management. Below I create an "Org" group for ~org-mode~ buffers.

    #+BEGIN_SRC emacs-lisp
      (setq ibuffer-saved-filter-groups
            '(("Standard"
               ("Emacs" (or (filename . ".*bnb-emacs.*")
                            (mode . emacs-lisp-mode)))
               ("Org" (mode . org-mode))
               ("Magit" (name . "\*magit"))
               ("Mail" (or (mode . message-mode)
                           (mode . mail-mode)))
               ("HTML" (mode . html-mode))
               ("Help" (or (name . "\*Help\*")
                           (name . "\*Apropos\*")
                           (name . "\*info\*"))))))
    #+END_SRC

**** VC Grouping

     The ~ibuffer-vc~ package provides groups according to version
     control sets. Here I setup a small keybinding to get to the
     filtered vc groups.  The keys =/ R= will go back to the standard
     view.

     #+BEGIN_SRC emacs-lisp
       (use-package ibuffer-vc :ensure t
         :bind
         (:map ibuffer-mode-map
               ("/ v" . ibuffer-vc-set-filter-groups-by-vc-root)))
     #+END_SRC

** Multiple Cursors

   This interface is a mix of an example on the [[https://github.com/abo-abo/hydra/wiki/multiple-cursors][hydra wiki]] and my own
   additions.

   I think that the key thing is remembering to not have this affect
   *all* cursors when prompted. Otherwise, it seems, the cursors are
   duplicated in strange ways.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind
       ("H-m"   . hydra-mc/body)
       ("C-x m" . hydra-mc/body)
       ("s-<mouse-1>" . mc/add-cursor-on-click)
       ("C-x M" . compose-mail)
       :config
       (defhydra hydra-mc (:hint nil)
        "
          ^Up^            ^Down^        ^Miscellaneous^
     -----------------------------------------------------------
     [_p_]   Next    [_n_]   Next    [_l_] Edit lines  [_x_] Arrows
     [_P_]   Skip    [_N_]   Skip    [_a_] Mark all    [_g_] Regexp
     [_M-p_] Unmark  [_M-n_] Unmark  [_q_] Quit"
       ("l"   mc/edit-lines :exit t)
       ("a"   mc/mark-all-like-this-dwim :exit t)
       ("n"   mc/mark-next-like-this)
       ("N"   mc/skip-to-next-like-this)
       ("M-n" mc/unmark-next-like-this)
       ("p"   mc/mark-previous-like-this)
       ("P"   mc/skip-to-previous-like-this)
       ("M-p" mc/unmark-previous-like-this)
       ("g"   mc/mark-all-in-region-regexp :exit t)
       ("r"   mc/mark-sgml-tag-pair :exit t)
       ("x"   mc/mark-more-like-this-extended)
       ("q"   nil))
     (add-hydra-mc-funcs))

     (defun add-hydra-mc-funcs ()
       "Add my hydra-mc funcs to the proper whitelist"
       (let* ((hydra-mc-funcs
               (cl-remove-if-not
                'functionp
                (apply #'append hydra-mc/heads)))
              (mc-funcs-to-ignore (cl-intersection
                                   hydra-mc-funcs
                                   mc--default-cmds-to-run-once))
              (funcs-to-whitelist
               (cl-mapcar
                (lambda (x) (intern (concat "hydra-mc/" (symbol-name x))))
                mc-funcs-to-ignore)))
         (let (value)
           (dolist (element funcs-to-whitelist nil)
             (add-to-list 'mc/cmds-to-run-once element)))))
   #+END_SRC

** Expand Region

   Nice way to expand selections to semantic regions. Read more on
   [[https://github.com/magnars/expand-region.el]].

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :bind ("C-=" . er/expand-region))
   #+END_SRC

** Hooks

   In general, hooks may be best with other configuration items, but
   if they are just pieces on their own, they belong here.

*** Ensure proper lisping

    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-save-hook  'check-parens nil t)
    #+END_SRC

*** Auto Reverting in modes

    For view-only buffers rendering content, it is useful to have them
    ~auto-revert~ in case of changes.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'doc-view-mode-hook 'auto-revert-mode)
      (add-hook 'image-mode 'auto-revert-mode)
    #+END_SRC

** Recentf

   I enable emacs remembering recently open files.

   #+BEGIN_SRC emacs-lisp
     (recentf-mode t)
   #+END_SRC

** Executable Scripts on save

   Taken from: http://mbork.pl/2015-01-10_A_few_random_Emacs_tips

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC

** Scroll Screen Position

   This is one of those cool finds for a problem I mostly knew that I
   had. I often hit =C-v= by accident and lose my place.  With the
   following setting, =M-v= completely undoes the scroll leaving the
   cursor back in the original position.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-preserve-screen-position 'always)
   #+END_SRC

   Thanks to http://irreal.org/blog/?p=3963 for the tip.

** Unique Buffer Names

   When editing files with the same name, but different location, a
   unique identifier (based on path) is preferred over a number.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :defer 10
       :ensure nil
       :config
       (setq uniquify-buffer-name-style 'post-forward
             uniquify-separator ":"))
   #+END_SRC

** Focus Mode                                                       :PENDING:

   Dim everything except for the thing-at-point. Improves focus when
   reading code and text.

   #+BEGIN_SRC emacs-lisp
     (use-package focus
       :ensure t
       :bind
       ("C-c f" . focus-mode)
       ("C-c F" . focus-read-only-mode))
   #+END_SRC

** Paperless Mode                                                   :PENDING:

   #+BEGIN_SRC emacs-lisp
     (use-package paperless
       :commands (paperless)
       :config
       (setq paperless-capture-directory "~/Desktop/"
             paperless-root-directory "~/Documents/Personal/"))
   #+END_SRC

** Relative line numbers                                            :PENDING:

#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :defer 10
    :ensure t)
#+END_SRC

** ImageMagick

   Register file types if we can.

   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'imagemagick-register-types)
       (imagemagick-register-types))
   #+END_SRC

** Schrute Mode                                                     :PENDING:

   #+BEGIN_SRC emacs-lisp
     (use-package schrute
       :diminish schrute-mode
       :defer 10
       :quelpa
       (schrute :fetcher github :repo "bnbeckwith/dwight-k.-schrute")
       :config
       (setf schrute-shortcuts-commands
             '((avy-goto-line . (next-line previous-line))
               (avy-goto-word-1 . (left-char right-char))))
       (schrute-mode))
   #+END_SRC

** Perspective                                                      :PENDING:

   Use tagged workspaces to keep work neat and tidy (I hope). Use `C-x
   x` to get the party started.

   #+BEGIN_SRC emacs-lisp
     (use-package persp-mode
       :bind
       (("C-x b" . persp-switch-to-buffer)
        ("C-x k" . persp-kill-buffer)
        ("C-x x x" . bnb/persp-ibuffer))
       :init
       (defun bnb/persp-ibuffer (arg)
         (interactive "P")
         (with-persp-buffer-list () (bs-show arg)))
       :config (persp-mode)

       (setq persp-autokill-buffer-on-remove 'kill-weak))
   #+END_SRC

   Switching projects puts us into a new perspective.

   #+BEGIN_SRC emacs-lisp
     (use-package persp-projectile
       :ensure t
       :bind ("C-x x f" . projectile-persp-switch-project))
   #+END_SRC

** Key frequency                                                    :PENDING:

   Record how often I use my keys.

   #+BEGIN_SRC emacs-lisp
     (use-package keyfreq
       :ensure t
       :init
       (keyfreq-mode 1)
       (keyfreq-autosave-mode 1))
   #+END_SRC

** PDF Tools

   #+BEGIN_SRC emacs-lisp
     (setenv "PKG_CONFIG_PATH" "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig:/usr/local/lib/pkgconfig:/opt/X11/lib/pkgconfig")

     (use-package pdf-tools
       :ensure t
       :defer 10
       :config (pdf-tools-install))
   #+END_SRC

** Helpful                                                          :PENDING:

   #+BEGIN_SRC emacs-lisp
     (use-package helpful
       :bind
       ("C-h f" . helpful-function)
       ("C-h x" . helpful-command)
       ("C-h z" . helpful-macro))
   #+END_SRC

* Style

  The following sections describe items that affect the visual
  elements of Emacs.

** Frame Changes

   These following items make Emacs really beautiful on every
   platform.  I remove the menu bar, tool bar and the scroll bar for
   starters.  Then, I setup the fringe area with some items

   #+BEGIN_SRC emacs-lisp
     (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
     (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
     (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
   #+END_SRC

** Window Changes
   
   In the fringe area, I like to have markers to show me where the
   buffer begins/ends on the right. On the left, I have emacs show
   little dashes where empty lines exist.
   
   In the title bar, I have it print the buffer name, full file name
   and size.

   #+BEGIN_SRC emacs-lisp
     (setq-default indicate-buffer-boundaries 'right)
     (setq-default indicate-empty-lines t)
     (setq-default frame-title-format '("%b %f %I"))
   #+END_SRC

** Faces
*** Default Fonts

    I love /Source Code Pro/, but I'm giving /Fira Code a try/ for
    some extra ligature fun.

    https://github.com/tonsky/FiraCode/wiki/Setting-up-Emacs

    #+BEGIN_SRC emacs-lisp
      (use-package ring
        :bind ("H-f" . bnb/font-next)
        ("H-F" . bnb/font-prev)
        :config
        (setq bnb/fontlist '("Fira Code-13" "Source Code Pro-13")
              bnb/font-ring
              (ring-convert-sequence-to-ring bnb/fontlist)
              bnb/font
              (ring-ref bnb/font-ring 0))
        (defun bnb/font-apply (font)
          (set-frame-font (setq bnb/font font))
          (message "Set default font to %s" bnb/font))
        (defun bnb/font-next ()
          (interactive)
          (bnb/font-apply (ring-next bnb/font-ring bnb/font)))
        (defun bnb/font-prev ()
          (interactive)
          (bnb/font-apply (ring-prev bnb/font-ring bnb/font)))
        (set-frame-font bnb/font))

      (defconst fira-code-font-lock-keywords-alist
        (mapcar (lambda (regex-char-pair)
                  `(,(car regex-char-pair)
                    (0 (prog1 ()
                         (compose-region (match-beginning 1)
                                         (match-end 1)
                                         ;; The first argument to concat is a string containing a literal tab
                                         ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
                '(("\\(www\\)"                   #Xe100)
                  ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
                  ("\\(\\*\\*\\*\\)"             #Xe102)
                  ("\\(\\*\\*/\\)"               #Xe103)
                  ("\\(\\*>\\)"                  #Xe104)
                  ("[^*]\\(\\*/\\)"              #Xe105)
                  ("\\(\\\\\\\\\\)"              #Xe106)
                  ("\\(\\\\\\\\\\\\\\)"          #Xe107)
                  ("\\({-\\)"                    #Xe108)
                  ("\\(\\[\\]\\)"                #Xe109)
                  ("\\(::\\)"                    #Xe10a)
                  ("\\(:::\\)"                   #Xe10b)
                  ("[^=]\\(:=\\)"                #Xe10c)
                  ("\\(!!\\)"                    #Xe10d)
                  ("\\(!=\\)"                    #Xe10e)
                  ("\\(!==\\)"                   #Xe10f)
                  ("\\(-}\\)"                    #Xe110)
                  ("\\(--\\)"                    #Xe111)
                  ("\\(---\\)"                   #Xe112)
                  ("\\(-->\\)"                   #Xe113)
                  ("[^-]\\(->\\)"                #Xe114)
                  ("\\(->>\\)"                   #Xe115)
                  ("\\(-<\\)"                    #Xe116)
                  ("\\(-<<\\)"                   #Xe117)
                  ("\\(-~\\)"                    #Xe118)
                  ("\\(#{\\)"                    #Xe119)
                  ("\\(#\\[\\)"                  #Xe11a)
                  ("\\(##\\)"                    #Xe11b)
                  ("\\(###\\)"                   #Xe11c)
                  ("\\(####\\)"                  #Xe11d)
                  ("\\(#(\\)"                    #Xe11e)
                  ("\\(#\\?\\)"                  #Xe11f)
                  ("\\(#_\\)"                    #Xe120)
                  ("\\(#_(\\)"                   #Xe121)
                  ("\\(\\.-\\)"                  #Xe122)
                  ("\\(\\.=\\)"                  #Xe123)
                  ("\\(\\.\\.\\)"                #Xe124)
                  ("\\(\\.\\.<\\)"               #Xe125)
                  ("\\(\\.\\.\\.\\)"             #Xe126)
                  ("\\(\\?=\\)"                  #Xe127)
                  ("\\(\\?\\?\\)"                #Xe128)
                  ("\\(;;\\)"                    #Xe129)
                  ("\\(/\\*\\)"                  #Xe12a)
                  ("\\(/\\*\\*\\)"               #Xe12b)
                  ("\\(/=\\)"                    #Xe12c)
                  ("\\(/==\\)"                   #Xe12d)
                  ("\\(/>\\)"                    #Xe12e)
                  ("\\(//\\)"                    #Xe12f)
                  ("\\(///\\)"                   #Xe130)
                  ("\\(&&\\)"                    #Xe131)
                  ("\\(||\\)"                    #Xe132)
                  ("\\(||=\\)"                   #Xe133)
                  ("[^|]\\(|=\\)"                #Xe134)
                  ("\\(|>\\)"                    #Xe135)
                  ("\\(\\^=\\)"                  #Xe136)
                  ("\\(\\$>\\)"                  #Xe137)
                  ("\\(\\+\\+\\)"                #Xe138)
                  ("\\(\\+\\+\\+\\)"             #Xe139)
                  ("\\(\\+>\\)"                  #Xe13a)
                  ("\\(=:=\\)"                   #Xe13b)
                  ("[^!/]\\(==\\)[^>]"           #Xe13c)
                  ("\\(===\\)"                   #Xe13d)
                  ("\\(==>\\)"                   #Xe13e)
                  ("[^=]\\(=>\\)"                #Xe13f)
                  ("\\(=>>\\)"                   #Xe140)
                  ("\\(<=\\)"                    #Xe141)
                  ("\\(=<<\\)"                   #Xe142)
                  ("\\(=/=\\)"                   #Xe143)
                  ("\\(>-\\)"                    #Xe144)
                  ("\\(>=\\)"                    #Xe145)
                  ("\\(>=>\\)"                   #Xe146)
                  ("[^-=]\\(>>\\)"               #Xe147)
                  ("\\(>>-\\)"                   #Xe148)
                  ("\\(>>=\\)"                   #Xe149)
                  ("\\(>>>\\)"                   #Xe14a)
                  ("\\(<\\*\\)"                  #Xe14b)
                  ("\\(<\\*>\\)"                 #Xe14c)
                  ("\\(<|\\)"                    #Xe14d)
                  ("\\(<|>\\)"                   #Xe14e)
                  ("\\(<\\$\\)"                  #Xe14f)
                  ("\\(<\\$>\\)"                 #Xe150)
                  ("\\(<!--\\)"                  #Xe151)
                  ("\\(<-\\)"                    #Xe152)
                  ("\\(<--\\)"                   #Xe153)
                  ("\\(<->\\)"                   #Xe154)
                  ("\\(<\\+\\)"                  #Xe155)
                  ("\\(<\\+>\\)"                 #Xe156)
                  ("\\(<=\\)"                    #Xe157)
                  ("\\(<==\\)"                   #Xe158)
                  ("\\(<=>\\)"                   #Xe159)
                  ("\\(<=<\\)"                   #Xe15a)
                  ("\\(<>\\)"                    #Xe15b)
                  ("[^-=]\\(<<\\)"               #Xe15c)
                  ("\\(<<-\\)"                   #Xe15d)
                  ("\\(<<=\\)"                   #Xe15e)
                  ("\\(<<<\\)"                   #Xe15f)
                  ("\\(<~\\)"                    #Xe160)
                  ("\\(<~~\\)"                   #Xe161)
                  ("\\(</\\)"                    #Xe162)
                  ("\\(</>\\)"                   #Xe163)
                  ("\\(~@\\)"                    #Xe164)
                  ("\\(~-\\)"                    #Xe165)
                  ("\\(~=\\)"                    #Xe166)
                  ("\\(~>\\)"                    #Xe167)
                  ("[^<]\\(~~\\)"                #Xe168)
                  ("\\(~~>\\)"                   #Xe169)
                  ("\\(%%\\)"                    #Xe16a)
                 ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
                  ("[^:=]\\(:\\)[^:=]"           #Xe16c)
                  ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
                  ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

      (defun add-fira-code-symbol-keywords ()
        (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

      ;;(add-fira-code-symbol-keywords)
    #+END_SRC

**** Unicode

     Support unicode fonts

     #+BEGIN_SRC emacs-lisp
       (use-package unicode-fonts
         :defer 10
         :config
         (unicode-fonts-setup))
     #+END_SRC

*** Trying out fonts on Windows

    #+BEGIN_SRC emacs-lisp
      (defun bnb/windows-set-font ()
        (interactive)
        (set-face-attribute 'default nil :font (w32-select-font)))
    #+END_SRC

*** Dynamic Font sizes

    Changing font sizes in presentations is crucial to have at hand. I
    use the following keybindings. =C--= overrides the negative
    argument function, but that one is also accessible by =M--=.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/change-frame-font-size (fn)
        (let* ((font-name (frame-parameter nil 'font))
               (decomposed-font-name (x-decompose-font-name font-name))
               (font-size (string-to-number (aref decomposed-font-name 5))))
          (aset decomposed-font-name 5 (int-to-string (funcall fn font-size)))
          (set-frame-font (x-compose-font-name decomposed-font-name))))

      (defun bnb/frame-text-scale-increase ()
        (interactive)
        (bnb/change-frame-font-size '1+))

      (defun bnb/frame-text-scale-decrease ()
        (interactive)
        (bnb/change-frame-font-size '1-))

      (bind-keys
       ("C-+" . text-scale-increase)
       ("C--" . text-scale-decrease)
       ("s--" . bnb/frame-text-scale-decrease)
       ("s-+" . bnb/frame-text-scale-increase)
       ("s-=" . bnb/frame-text-scale-increase))
    #+END_SRC

*** Mode Line Style

    I dislike the box around the =mode-line= making it look like a
    button. I disable (set to =nil=) this face attribute, =box=, to
    get a flat feel. Be sure to do it to all =mode-line= faces that
    have this attribute.

    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'mode-line nil :box nil)
      (set-face-attribute 'mode-line-inactive nil :box nil)
      (set-face-attribute 'mode-line-highlight nil :box nil)
    #+END_SRC

*** Missing Glyphs

    If I ever use a font with a missing glyph, this will let Emacs
    check the /Symbola/ font for the missing data.

    [[http://users.teilar.gr/~g1951d/][Download Symbola]] if you do not have it.

    #+BEGIN_SRC emacs-lisp
      (set-fontset-font "fontset-default" nil
                        (font-spec :size 20 :name "Symbola"))
    #+END_SRC

** Themes

   I used to have [[http://www.greghendershott.com/2017/02/emacs-themes.html][something else]] from [[http://www.greghendershott.com][Greg Hendershot]], but now I
   created my own theme override and layer it corectly.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/disable-all-themes ()
         (interactive)
         (mapc #'disable-theme custom-enabled-themes))
   #+END_SRC

   On creating themes: https://www.gnu.org/software/emacs/manual/html_node/emacs/Creating-Custom-Themes.html#Creating-Custom-Themes

*** Extra Themes

    #+BEGIN_SRC emacs-lisp
      (use-package gruvbox-theme :ensure t :defer t)
      (use-package material-theme :ensure t :defer t)
    #+END_SRC

** Smart Mode Line

   This package reduces the noise in the mode-line and allows me to
   customize just the pieces that I need.

   #+BEGIN_SRC emacs-lisp
     (use-package smart-mode-line
       :ensure t
       :init
       (setq sml/theme 'respectful)
       (sml/setup))

     (setq bnb/sml-adjustment 3)
     (defun bnb/sml-subtract-adjustment (width)
        (- width bnb/sml-adjustment))
     (add-function :filter-return
         	  (symbol-function 'sml/fill-width-available)
         	  #'bnb/sml-subtract-adjustment)
   #+END_SRC

** Font lock profiling                                              :PENDING:

   Allow for profiling of font-locking.

   #+BEGIN_SRC emacs-lisp
     (use-package font-lock-profiler
       :commands (font-lock-profiler-start
                  font-lock-profiler-buffer
                  font-lock-profiler-region))
   #+END_SRC

** Pretty Symbols

*** Pretty mode

   #+BEGIN_SRC emacs-lisp
     (use-package pretty-mode
       :disabled
       :config
       (global-pretty-mode t)
       (pretty-activate-groups
        '(:sub-and-superscripts :greek :arithmetic-nary)))
   #+END_SRC

*** Prettify symbols mode

    #+BEGIN_SRC emacs-lisp
      (use-package prog-mode ; Contains pretty-symbols-mode
        :ensure nil
        :config
        (setq prettify-symbols-unprettify-at-point 'right-edge)
        (global-prettify-symbols-mode t)
        (add-hook
         'python-mode-hook
         (lambda ()
           (mapc (lambda (pair) (push pair prettify-symbols-alist))
                 '(;; Syntax
                   ("def" .      ?ℱ)
                   ("not" .      ?❗)
                   ("in" .       ?∈)
                   ("not in" .   ?∉)
                   ("return" .   ?⟼)
                   ("yield" .    ?⟻)
                   ("for" .      ?∀)
                   ;; Base Types
                   ("int" .      ?ℤ)
                   ("float" .    ?ℝ)
                   ("str" .      ?𝕊)
                   ("True" .     ?𝕋)
                   ("False" .    ?𝔽)
                   ;; Mypy
                   ("Dict" .     ?𝔇)
                   ("List" .     ?ℒ)
                   ("Tuple" .    ?⨂)
                   ("Set" .      ?Ω)
                   ("Iterable" . ?𝔊)
                   ("Any" .      ?❔)
                   ("Union" .    ?∪))))))
    #+END_SRC

** Color
*** Rainbow Mode

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-mode
        :commands (rainbow-mode)
        :ensure t)
    #+END_SRC

*** KureColor

    Color helper

    #+BEGIN_SRC emacs-lisp
      (use-package kurecolor
        :bind (("H-k" . kurecolor-increase-hue-by-step)
               ("H-j" . kurecolor-decrease-hue-by-step)
               ("s-k" . kurecolor-increase-saturation-by-step)
               ("s-j" . kurecolor-decrease-saturation-by-step)
               ("s-l" . kurecolor-increase-brightness-by-step)
               ("s-h" . kurecolor-decrease-brightness-by-step))
        :ensure t)
    #+END_SRC

* BNB Helpers

  This is a collection of code specific to how I use emacs. Some
  are from different websites or other Emacs users.

** Exit behavior

   Instead of exiting emacs, I prefer to leave it running and only
   minimize (iconize) it. Especially since I use =server= with emacs,
   it is advantageous to not kill my session by accident
   (muscle-memory). This idea is from [[http://emacs-fu.blogspot.com/2009/03/windows-and-daemons.html][Emacs-Fu]].

   To accomplish this, I advise the =kill-emacs= function. But first,
   I need to have some pieces in place to perform some functionality
   if a killing operation triggers (keystrokes, button presses,
   etc).

   I create a variable, =bnb/kill-emacs-hooks=, for functions that
   need to run before emacs is /killed/.

   #+BEGIN_SRC emacs-lisp
     (defvar bnb/kill-emacs-hooks)
     (add-hook 'bnb/kill-emacs-hooks
               (lambda () (if (functionp 'server-edit)(server-edit))))
   #+END_SRC

   In the hook above, I call the =server-edit= function to act as if
   I am closing emacs for a file opened via the server API. This has
   the effect of providing an illusion of opening the editor on a
   specific file and then closing it with normal keypresses.

   Next, I provide a flag and a function to set the flag if emacs is
   to really exit. We always need an escape hatch.

   #+BEGIN_SRC emacs-lisp
     (defvar bnb/really-kill-emacs nil)
     (defun bnb/kill-emacs ()
       (interactive)
       (setq bnb/really-kill-emacs t)
       (kill-emacs))
   #+END_SRC

   Now that mechanism is in place, it is time to augment
   =kill-emacs= with some advice around the function.

   #+BEGIN_SRC emacs-lisp
     (defadvice kill-emacs (around bnb/pardon-emacs activate)
       "Only kill emacs if a prefix is set"
       (run-hooks 'bnb/kill-emacs-hooks)
       (if bnb/really-kill-emacs
           ad-do-it
         (iconify-frame)))
   #+END_SRC

   Now, when any event triggers a call to =kill-emacs=, a small set
   of activities happen. First, the =bnb/kill-emacs-hooks= execute
   and perform their jobs. Next, I check the flag for /really/
   exiting and then call the proper =kill-emacs= if true. Otherwise,
   the flag is false and emacs is simply iconified.

** Workweeks

   This is vestigal content from my Intel days and this generates
   their idea of a work week number.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/workweek ()
       (interactive)
       (let* ((now (current-time))
              (weeks (string-to-number
                      (format-time-string "%W" now)))
              (days (time-to-day-in-year now))
              (daynum (string-to-number
                       (format-time-string "%w" now)))
              (left (% days 7)))
         (if (and (= 0 daynum) (= left 0))
             weeks
           (+ 1 weeks))))

     (defun bnb/workweek-string ()
       (interactive)
       (concat "WW"
               (number-to-string
                (bnb/workweek))))

     (require 'calendar)
     (defun bnb/workweek-from-gregorian (&optional date)
       (let* ((date (or date (calendar-current-date)))
              (year (calendar-extract-year date))
              (fst (calendar-day-of-week (list 1 1 year)))
              (x   (if (>= fst 4)1 0)))
         (+ x
            (car
             (calendar-iso-from-absolute
              (calendar-absolute-from-gregorian date))))))

     (setq calendar-week-start-day 1
           calendar-intermonth-text
             '(propertize
               (format "%2d"
                       (bnb/workweek-from-gregorian (list month day year)))
               'font-lock-face 'font-lock-function-name-face))

   #+END_SRC

** Better window splitting functions

   http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury

   These settings split the window and load a previous buffer (instead
   of the same buffer in both).  This has a better chance of being
   what I want when splitting strings.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/vplit-last-buffer ()
       (interactive)
       (split-window-vertically)
       (other-window 1 nil)
       (switch-to-next-buffer))

     (defun bnb/hsplit-last-buffer ()
       (interactive)
       (split-window-horizontally)
       (other-window 1 nil)
       (switch-to-next-buffer))

     (bind-keys
      ("C-x 2" . bnb/vplit-last-buffer)
      ("C-x 3" . bnb/hsplit-last-buffer))
   #+END_SRC

** Weekly Time Reporting

   This is a function to create an entry like a datetree, but using
   years and workweeks instead.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/find-year-create (year)
       (let ((re "^\\**[ \t]+\\([12][0-9]\\{3\\}\\)")
             match)
         (org-narrow-to-subtree)
         (goto-char (point-min))
         (while (and (setq match (re-search-forward re nil t))
                     (goto-char (match-beginning 1))
                     (< (string-to-number (match-string 1)) year)))
         (cond
          ((not match)
           (goto-char (point-max))
           (or (bolp) (newline))
           (insert (format  "** %s\n" year)))
          ((= (string-to-number (match-string 1)) year)
           (goto-char (point-at-bol)))
          (t
           (beginning-of-line 1)
           (insert (format  "** %s\n" year))))))

     (defun bnb/find-ww-create (ww)
       (let ((re "^\\**[ \t]+\\WW\\([0-9]\\{2\\}\\)")
             match)
         (org-narrow-to-subtree)
         (goto-char (point-min))
         (while (and (setq match (re-search-forward re nil t))
                     (goto-char (match-beginning 1))
                     (< (string-to-number (match-string 1)) ww)))
         (cond
          ((not match)
           (goto-char (point-max))
           (or (bolp) (newline))
           (insert (format "*** WW%02d\n" ww)))
          ((= (string-to-number (match-string 1)) ww)
           (goto-char (point-at-bol)))
          (t
           (beginning-of-line 1)
           (insert (format "*** WW%02d\n" ww))))))

     (defun bnb/insert-weekly-time-sheet ()
       (with-temp-buffer
         (insert
               (concat  "#+BEGIN: clocktable :maxlevel 3 :scope agenda-with-archives :block lastweek :fileskip0 t :properties (\"Score\") :indent nil \n"
                        "#+TBLFM: $6='(org-clock-time% @2$4 $3..$5);%.1f::@2$2=vsum(@3$2..@>$2)\n"
                        "#+END:\n\n"))
              (goto-char (point-min))
              (org-update-dblock)
              (buffer-substring (point-min) (point-max))))

          (defun bnb/insert-weekly-clocking ()
              (let ((year (number-to-string (nth 2 (calendar-gregorian-from-absolute (org-today)))))
                    (ww (bnb/workweek)))
                (goto-char (point-min))
                (goto-char (cdr (org-id-find "clocking")))
                (bnb/find-year-create (string-to-number year))
                (bnb/find-ww-create ww)))
   #+END_SRC

** Weekly Score Goal in Org-Agenda

   I use a scoring system to keep track of my overall progress.  This
   involves scoring my tasks and attributing my idea of impact of a
   particular done item.

   To use these numbers, I do a weekly review on Monday and compare
   the numbers to past years/weeks/etc. To keep pushing forward, this
   little bit of code will insert a running status at the top of my
   agenda.

   If I am on track for the given day (at or above the scaled goal),
   all is green.  Otherwise, I get a warning type formatting above 80%
   and error type formatting under.

#+BEGIN_SRC emacs-lisp
  ;; Define my goal to hit
  (defvar bnb/weekly-score-goal 42)

  ;; Add up all the scores from DONE items in the agenda files
  (defun bnb/agenda-score-goal ()
    (let* ((score ;; Add up all scores from DONE items
            (apply '+
                   (org-map-entries
                    (lambda () (string-to-number (or (org-entry-get (point) "Score") "0")))
                    "/DONE" 'agenda)))
           (scaled-goal (* bnb/weekly-score-goal (/ (string-to-number (format-time-string "%w")) 5.0)))
           (face (cond ((>= score scaled-goal) 'success)
                       ((>= score (* .8 scaled-goal)) 'warning)
                       (t 'error))))
      (insert
       (concat
        (propertize
         (format "Score Goal (%d): " scaled-goal) 'face 'org-agenda-structure)
        (propertize
         (format "%d/%d\n" score bnb/weekly-score-goal) 'face face)))))

  ;; This hook runs first in the agenda (and before it is set to read-only)
  (add-hook 'org-agenda-mode-hook 'bnb/agenda-score-goal)
#+END_SRC

** Calendars

   #+BEGIN_SRC emacs-lisp
     (setq bnb/calfw-calendars-list nil)

     (defun bnb/add-calendar (calendar)
       (add-to-list bnb/calfw-calendars-list calendar))

     (use-package sunshine
         :ensure t
         :commands (bnb/get-forecast-data)
         :config
         (defun bnb/get-forecast-data (b e)
           (let* ((url (sunshine-make-url sunshine-location sunshine-units sunshine-appid))
                  (forecast (if (sunshine-forecast-cache-expired url)
                                (with-current-buffer (url-retrieve-synchronously url)
                                  (goto-char (point-min))
                                  (sunshine-extract-response))
                              (with-temp-buffer
                                (mm-disable-multibyte)
                                (url-cache-extract (url-cache-create-filename url))
                                (sunshine-extract-response)))))
             (cl-loop for day across (cdr (assoc 'list forecast)) collect
                      (make-cfw:event
                       :title (format "%s/%s°, %s"
                                      (round (cdr (assoc 'min (cdr (assoc 'temp day)))))
                                      (round (cdr (assoc 'max (cdr (assoc 'temp day)))))
                                      (cdr (assoc 'main (elt (cdr (assoc 'weather day)) 0))))
                       :start-date (cfw:emacs-to-calendar (seconds-to-time (cdr (assoc 'dt day)))))))))

     (use-package calfw
       :ensure t
       :commands (bnb/calfw-calendars)
       :config
       (use-package calfw-cal :ensure nil)
       (use-package calfw-ical :ensure nil)
       (use-package calfw-org :ensure nil)
       (setq bnb/calfw-calendars-list
             (list (cfw:org-create-source "purple")
                   (make-cfw:source :name "Weather" :data 'bnb/get-forecast-data :color "IndianRed")))
       (defun bnb/calfw-calendars ()
         (interactive)
         (cfw:open-calendar-buffer
          :contents-sources bnb/calfw-calendars-list)))
   #+END_SRC

** Auto-display agenda

    From
    http://lists.gnu.org/archive/html/emacs-orgmode/2010-03/msg00367.html,
    John Weigley shows a way to display the agenda after some period
    of inactivity.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/jump-to-org-agenda ()
       (interactive)
       (let ((buf (get-buffer "*Org Agenda*"))
             wind)
         (if buf
             (if (setq wind (get-buffer-window buf))
                 (select-window wind)
               (if (called-interactively-p)
                   (progn
                     (select-window (display-buffer buf t t))
                     (org-fit-window-to-buffer))
                 (with-selected-window (display-buffer buf)
                   (org-fit-window-to-buffer))))
            (bnb/org-agenda-with-tip nil))))

     (defun bnb/idle-agenda (&optional arg)
       (interactive "P")
       (setq bnb/iagenda
             (if arg
                 (cancel-timer bnb/iagenda)
               (run-with-idle-timer 3600 t 'bnb/jump-to-org-agenda))))

     (bnb/idle-agenda)
   #+END_SRC

** Transparency

   #+BEGIN_SRC emacs-lisp
     (use-package ring
       :commands (bnb/transparency-apply bnb/transparency-next bnb/transparency-previous
                                         bnb/transparency-cycle bnb/transparency-add)
       :config
       (setq bnb/transparency-ring
             (ring-convert-sequence-to-ring (list '(100 100) '(100 50) '(100 10) '(95 50) '(90 50) '(85 50)))
             bnb/transparency
             (ring-ref bnb/transparency-ring 0))

       (defun bnb/transparency-apply (trans)
         (set-frame-parameter (selected-frame) 'alpha (setq bnb/transparency trans)))

       (defun bnb/transparency-next ()
         (interactive)
         (bnb/transparency-apply (ring-next bnb/transparency-ring bnb/transparency)))

       (defun bnb/transparency-previous ()
         (interactive)
         (bnb/transparency-apply (ring-previous bnb/transparency-ring bnb/transparency)))

       (defun bnb/transparency-cycle ()
         (interactive)
         (bnb/transparency-next))

       (defun bnb/transparency-add (active inactive)
         (interactive "nActive Transparency:\nnInactive Transparency:")
         (ring-insert+extend bnb/transparency-ring (list active inactive) t)
         (bnb/transparency-apply (list active inactive))))
   #+END_SRC

** Compile on save                                                  :PENDING:

   Whenever I save this file, I'd like to have it
   auto-compiled. First, I setup a function with the right steps.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/compile-readme ()
       (interactive)
       (let ((src "~/.emacs.d/bnb-emacs/Readme.org")
             (dst "~/.emacs.d/bnb-emacs/Readme.el"))
         (when (file-newer-than-file-p src dst)
           (org-babel-tangle-file src dst "emacs-lisp"))
         (byte-recompile-file dst t 0 nil)))
   #+END_SRC

** Styled HTML Export

   This is how I get the one-page html output for Github Pages. There
   are two main parts to setting up and executing the export.

   First, I use a =SETUPFILE= from
   https://github.com/fniessen/org-html-themes. Specifically, I use
   the /readtheorg/ style.

   Second, I setup the emacs theme correctly for nice code
   output. Syntax highlighting in the export will pull from the
   current theme. I don't want this. Instead, I want to specify which
   theme to use for /every/ export.

   The code below stores away the current list of enabled themes
   before disabling them all. Then, it enables my preferred export
   theme (~sanityinc-tomorrow-day~) before performing the
   export. Finally, it disables the last theme and renables all of the
   ones on the list.

   #+BEGIN_SRC emacs-lisp
     (defun bnb/export-readme ()
       (interactive)
       (let ((themes custom-enabled-themes))
         (mapc 'disable-theme themes)
         (load-theme 'sanityinc-tomorrow-day)
         (org-html-export-to-html)
         (rename-file "Readme.html" "index.html" t)
         (disable-theme 'sanityinc-tomorrow-day)
         (mapcar 'load-theme (reverse themes))))
   #+END_SRC

** Auto-indent when pasting

   Automatically indent pasted blocks of text.

   #+BEGIN_SRC elisp
     (dolist (command '(yank yank-pop))
        (eval `(defadvice ,command (after indent-region activate)
                 (and (not current-prefix-arg)
                      (let ((mark-even-if-inactive transient-mark-mode))
                        (indent-region (region-beginning) (region-end) nil))))))
   #+END_SRC

** Hide mode line                                                   :PENDING:

   This is a fun one I picked from [[https://ogbe.net/emacsconfig.html]]
   This block of code hides the mode-line for the current buffer
   (window).

   #+BEGIN_SRC emacs-lisp
     (defvar-local bnb/hide-mode-line-mode nil)
     (define-minor-mode bnb/hide-mode-line-mode
       "Minor mode to hide mode-line in current buffer"
       :init-value nil
       :global nil
       :variable bnb/hide-mode-line-mode
       :group 'editing-basics
       (if bnb/hide-mode-line-mode
           (setq bnb/hide-mode-line-mode/saved-format mode-line-format
                 mode-line-format nil)
         (setq mode-line-format bnb/hide-mode-line-mode/saved-format
               bnb/hide-mode-line-mode/saved-format nil))
       (force-mode-line-update)
       (redraw-display)
       (when (and (called-interactively-p 'interactive)
                  hidden-mode-line-mode)
         (run-with-idle-timer
          0 nil 'message
          (concat "Goodbye mode line!"
                  "Use M-x hidden-mode-line-mode to make the mode-line appear"))))
   #+END_SRC

* Company
  
  [[http://company-mode.github.io][Company Mode]] is an in-buffer completion system. To get started, I
  need to load the mode and bind some keys.

  #+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :diminish company-mode
      :init
      (add-hook 'after-init-hook 'global-company-mode)
      :bind
      ("<C-tab>" . company-complete-common-or-cycle)
      :config
      (bind-key "C-<tab>" 'company-complete org-mode-map)
      (bind-keys :map company-active-map
                 ("s-<tab>" . company-complete-common-or-cycle)
                 ("C-n"     . company-select-next)
                 ("C-p"     . company-select-previous))
      ;; Turn off the auto downcasing of things
      (setq company-dabbrev-downcase nil
            company-show-numbers t
            company-tooltip-align-annotations t
            company-selection-wrap-around t
            company-tooltip-flip-when-above t
            company-dabbrev-code-everywhere t
            company-dabbrev-code-ignore-case t))
  #+END_SRC


* File Management
** Dired

   So, I used =dired+= instead of the regular =dired=. It offers more
   interesting colors and more flexible ways to mark files.

   For example, to mark by extension, press =*.=, then type the
   extension (with dot).

   Here I enable the =dired-find-alternate-file= command. It lets my
   just type =a= to replace the current buffer and reduces the
   accumulating =dired= buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package dired+
       :after dired
       :ensure t
       :config
       (put 'dired-find-alternate-file 'disabled nil)
       (when (eq system-type 'windows-nt)
         (setq dired-guess-shell-alist-user
               '(("\\.pdf" "SumatraPDF.exe")))))
   #+END_SRC

   Also, there is a nice faculty to run an external command on a given
   file with =!=.  =Dired= has some idea of what to run, but I can make
   it smarter on windows.

** Sunrise Commander

   I always seem to need something better than =dired= when moving
   files around. Sunrise commander seems to fit the bill nicely.

   #+BEGIN_SRC emacs-lisp
     (use-package sunrise-commander
       :bind ("<f8>" . sunrise))
   #+END_SRC

** OSX Reveal

   Show files in finder.

   #+BEGIN_SRC emacs-lisp
     (use-package reveal-in-osx-finder
       :ensure t
       :bind ("C-c z" . reveal-in-osx-finder))
   #+END_SRC

* Smart Tabs

  [[http://www.emacswiki.org/emacs-en/SmartTabs][SmartTabs]] try to do the right thing regarding tabs/spaces in
  indentation/alignment. It installs through the package interface. Look for
  =smart-tabs-mode=.

  By default, I'm enabling it in all modes that I can.

  Since we are dealing with tabs here, I also take the time to set
  the default width to 4. Because of the way this mode works, any
  change in the default width will result in code that still aligns.

  #+BEGIN_SRC emacs-lisp
    (use-package smart-tabs-mode
      :defer 10
      :ensure t
      :init
      (setq-default indent-tabs-mode nil)
      (smart-tabs-insinuate 'c 'cperl 'c++)
      (setq-default tab-width 2))
  #+END_SRC

** Notes

   To re-tab the whole file, use =C-x h C-M-\=.

* CUA mode

  [[info:emacs#CUA%20Bindings][CUA]] has a primary feature of enabling cut, copy, paste and undo
  shortcuts compatible with most applications (C-x, C-c,
  C-v). However, it also has interesting rectangle features and
  *that* is why I enable it. I also happen to turn off those other
  bindings and prefer the emacs defaults.

  #+BEGIN_SRC emacs-lisp
    (cua-mode t)
    (setq cua-enable-cua-keys nil)
  #+END_SRC

** Bindings

*** CUA Rectangles

    These take place with an active rectangle. To start/cancel a
    rectangle use =C-RET=.

    | Keys             | Function                                                              |
    |------------------+-----------------------------------------------------------------------|
    | M-<arrow>        | Move rectangle overlay                                                |
    | C-SPACE          | Activate region bounded by rectangle                                  |
    |------------------+-----------------------------------------------------------------------|
    | M-a              | Align all words at the left edge                                      |
    | M-b              | Fill rectangle with blanks (tabs and spaces)                          |
    | M-c              | Closes the rectangle by removing left edge blanks                     |
    | M-f              | Fills the rectangle with a single character (prompt)                  |
    | M-i              | Increases number found on each line of rectangle                      |
    | M-k              | Kills the rectangle as normal multi-line kill                         |
    | M-l              | Downcases the rectangle                                               |
    | M-m              | Copies the rectangle for normal multi-line paste                      |
    | M-n              | Fills each line with increasing numbers (prompt)                     |
    | M-o              | Opens the rect by moving hilighted text right and filling with blanks |
    | M-p              | Toggles virtual straight rectangle edges                              |
    | M-P              | Inserts tabs and spaces to make real straight edges                   |
    | M-q              | Performs text filling on the rectangle                                |
    | M-q              | Performs text filling on the rectangle                                |
    | M-r              | Replaces REGEXP (prompt) by STRING (prompt) in rectangle              |
    | M-R              | Reverse the lines in the rectangle                                    |
    | M-s              | Fills each line of the rectangle with the same STRING (prompt)        |
    | M-t              | Performs text fill of the rectangle with TEXT (prompt)                |
    | M-u              | Upcases the rectangle                                                 |
    | M-<Vertical Bar> | Runs shell command on rectangle                                       |
    | M-'              | Restricts rectangle to lines with CHAR (prompt) at left column        |
    | M-/              | Restricts rectangle to lines matching REGEXP (prompt)                 |
    | C-?              | Shows a brief list of the above commands.                             |
    |------------------+-----------------------------------------------------------------------|
    | M-C-<UP/DOWN>    | Scrolls the lines INSIDE the rectangle up/down                        |

*** CUA Global Mark

    The global mark feature enables a target the receives any
    typed/copied/killed text from any buffer (even the current one).

    | Key           | function                                                                                                            |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | <ch>          | All characters (including newlines) you type are inserted at the global mark!                                       |
    | C-x           | If you cut a region or rectangle, it is automatically inserted at the global mark, and the global mark is advanced. |
    | C-c           | If you copy a region or rectangle, it is immediately inserted  at the global mark, and the global mark is advanced. |
    | C-v           | Copies a single character to the global mark.                                                                       |
    | C-d           | Moves (i.e. deletes and inserts) a single character to the global mark.                                             |
    | backspace     | deletes the character before the global mark                                                                        |
    | delete        | deletes the character after the global mark.                                                                        |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | S-C-space     | Jumps to and cancels the global mark.                                                                               |
    | C-u S-C-space | Cancels the global mark (stays in current buffer).                                                                  |
    |---------------+---------------------------------------------------------------------------------------------------------------------|
    | TAB           | Indents the current line or rectangle to the column of the global mark.                                             |


* Paredit

  I added =paredit-mode= to several of the lisp modes that follow.

  [[http://www.emacswiki.org/emacs/PareditCheatsheet][Paredit Cheatsheet]]

  [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][Animated Paredit]]

  #+BEGIN_SRC emacs-lisp
    (use-package paredit
      :commands (paredit-mode)
      :ensure t)
  #+END_SRC

* Paxedit

  Maybe even /more/ power for lisp coding?
  [[https://github.com/promethial/paxedit][Paxedit repo]]

  #+BEGIN_SRC emacs-lisp
    (use-package paxedit
      :ensure t
      :commands (paxedit-mode)
      :bind
      ("M-<right>" . paxedit-transpose-forward)
      ("M-<left>"  . paxedit-transpose-backward)
      ("M-<up>"    . paxedit-backward-up)
      ("M-<down>"  . paxedit-backward-end)
      ("M-b"       . paxedit-previous-symbol)
      ("M-f"       . paxedit-next-symbol)
      ("C-%"       . paxedit-copy)
      ("C-&"       . paxedit-kill)
      ("C-*"       . paxedit-delete)
      ("C-^"       . paxedit-sexp-raise)
      ("M-u"       . paxedit-symbol-change-case)
      ("C-@"       . paxedit-symbol-copy)
      ("C-#"       . paxedit-symbol-kill))      
  #+END_SRC

* Projectile

  Handling project buffers and files may be easier with projectile.
  Currently under evaluation.

  From the [[https://github.com/abo-abo/hydra/wiki/Projectile][Hydra Wiki]], the additional hydras launch the projectile
  functions.

  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :bind
      ("C-x w" . hydra-projectile-other-window/body)
      ("C-c C-p" . hydra-projectile/body)
      :config
      (use-package counsel-projectile
        :ensure t)
      (when (eq system-type 'windows-nt)
        (setq projectile-indexing-method 'native))
      (setq projectile-enable-caching t
            projectile-require-project-root t
            projectile-mode-line '(:eval (format " 🛠[%s]" (projectile-project-name)))
            projectile-completion-system 'default)
      (projectile-mode)
      (defhydra hydra-projectile-other-window (:color teal)
                  "projectile-other-window"
                  ("f"  projectile-find-file-other-window        "file")
                  ("g"  projectile-find-file-dwim-other-window   "file dwim")
                  ("d"  projectile-find-dir-other-window         "dir")
                  ("b"  projectile-switch-to-buffer-other-window "buffer")
                  ("q"  nil                                      "cancel" :color blue))
      (defhydra hydra-projectile (:color teal :hint nil)
                  "
         PROJECTILE: %(projectile-project-root)

         Find File            Search/Tags          Buffers                Cache
    ------------------------------------------------------------------------------------------
    _C-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
     _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
     _fd_: file curr dir   _o_: multi-occur     _C-k_: Kill all buffers  _X_: cleanup non-existing
      _r_: recent file                                               ^^^^_z_: cache current
      _d_: dir

    "
                  ("a"   counsel-projectile-ag)
                  ("b"   projectile-switch-to-buffer)
                  ("c"   projectile-invalidate-cache)
                  ("d"   projectile-find-dir)
                  ("C-f" projectile-find-file)
                  ("ff"  projectile-find-file-dwim)
                  ("fd"  projectile-find-file-in-directory)
                  ("g"   ggtags-update-tags)
                  ("C-g" ggtags-update-tags)
                  ("i"   projectile-ibuffer)
                  ("K"   projectile-kill-buffers)
                  ("C-k" projectile-kill-buffers)
                  ("m"   projectile-multi-occur)
                  ("o"   projectile-multi-occur)
                  ("C-p" projectile-switch-project "switch project")
                  ("p"   projectile-switch-project)
                  ("s"   projectile-switch-project)
                  ("r"   projectile-recentf)
                  ("x"   projectile-remove-known-project)
                  ("X"   projectile-cleanup-known-projects)
                  ("z"   projectile-cache-current-file)
                  ("`"   hydra-projectile-other-window/body "other window")
                  ("q"   nil "cancel" :color blue)))
  #+END_SRC

** Rails

   #+BEGIN_SRC emacs-lisp
     (use-package projectile-rails
       :ensure t
       :bind
       ("s-r" . hydra-projectile-rails/body)
       :config
       (setq projectile-rails-keymap-prefix (kbd "C-c p C-r"))
       (projectile-rails-global-mode))
   #+END_SRC

* Programming Languages
** Utilities
*** Flycheck

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer 10
        :init (global-flycheck-mode)
        :config
        (bind-key "H-!"
          (defhydra hydra-toggle (:color amaranth)
            "
      _c_ Check buffer      _x_ Explain error
      _n_ Next error        _h_ Show error
      _p_ Previous error
      _l_ Show all errors   _s_ Select syntax checker
      _C_ Clear errors      _?_ Describe syntax checker
      "
            ("c" flycheck-buffer)
            ("n" flycheck-next-error)
            ("p" flycheck-previous-error)
            ("l" flycheck-list-errors)
            ("C" flycheck-clear-errors)
            ("x" flycheck-explain-error-at-point)
            ("h" flycheck-display-error-at-point)
            ("s" flycheck-select-checker)
            ("?" flycheck-describe-checker)
            ("q" nil))))
    #+END_SRC

** Clojure

   The easiest way to edit clojure code is with =paredit= so let's have
   it automatically load each time.

   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :defer
       :ensure t
       :config
       (add-hook 'clojure-mode-hook 'paredit-mode)
       (add-hook 'clojure-mode-hook 'cljr-clojure-mode-hook)
       (add-hook 'clojure-mode-hook 'paxedit-mode))
   #+END_SRC

*** Cider

    Using Cider will make a nREPL available for Clojure
    programming. The configuration snippets here are from the [[https://github.com/clojure-emacs/cider][project
    page on github]].

    #+BEGIN_SRC emacs-lisp
      (use-package cider
        :ensure t
        :commands (cider-jack-in)
        :config
        ;; Enable eldoc
        (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
        ;; Hide special buffers
        (setq nrepl-hide-special-buffers t
        ;; Stop the error from popping up while working in buffers other than the REPL
              cider-popup-stacktraces nil
        ;; Stop prompting to save file when killing repl buffer
              cider-prompt-save-file-on-load nil))
    #+END_SRC

*** clj-refactor

    Refactoring clojure code is made easier with [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor.el]].  I
    turn it on for any clojure mode (through hooks).  The keybinding
    for the set of commands is prefixed with =C-c C-r= as shown below.

    #+BEGIN_SRC emacs-lisp
      (use-package clj-refactor
        :commands (cljr-clojure-mode-hook)
        :init
        (add-hook 'clojure-mode-hook #'cljr-clojure-mode-hook)
        :config
        (defun cljr-clojure-mode-hook ()
          (clj-refactor-mode 1)
          (yas-minor-mode 1)
          (cljr-add-keybindings-with-prefix "C-c C-r")))
    #+END_SRC

    The wiki hosts the [[https://github.com/clojure-emacs/clj-refactor.el/wiki][available refactorings]].
    
** Common Lisp

   #+BEGIN_SRC emacs-lisp
     (use-package slime
       :commands (slime)
       :ensure t
       :config
       (setq inferior-lisp-program "/usr/local/bin/sbcl"
             slime-net-coding-system 'utf-8-unix)
       (slime-setup '(slime-fancy)))
   #+END_SRC

** Elisp

   When modified =emacs-lisp=, it is most helpful to use =paredit= and
   =eldoc=.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
     (add-hook 'emacs-lisp-mode-hook 'paxedit-mode)
     (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
   #+END_SRC

** Ember

   Use ~ember-mode~ to move around nicely

   #+BEGIN_SRC emacs-lisp
     (use-package ember-mode
       :commands (ember-mode)
       :defer)
   #+END_SRC

** Javascript

   Let's make some javascript settings!

   #+BEGIN_SRC emacs-lisp
     (setq js-indent-level 2)
   #+END_SRC

   Additional setup from https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html

*** JS2

    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :mode "\\.js\\'"
        :init
        (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
        :config
        (setq js2-basic-offset 2))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package js2-refactor
        :after js2-mode
        :functions (js2r-add-keybindings-with-prefix)
        :bind (:map js2-mode-map
                    ("C-k" . js2r-kill))
        :config
        (js2r-add-keybindings-with-prefix "C-c C-r"))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package xref-js2
        :after js2-mode
        :config
        (add-hook 'js2-mode-hook
                  (lambda ()
                    (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))
    #+END_SRC

*** Company tern

    #+BEGIN_SRC emacs-lisp
      (use-package company-tern
        :after js2-mode
        :config
        (add-to-list 'company-backends 'company-tern)
        (add-to-list 'tern-command "--no-port-file" 'append)
        (add-hook 'js2-mode-hook (lambda ()
                                   (tern-mode)
                                   (company-mode))))
    #+END_SRC

** Ruby

   I followed along with [[https://lorefnon.me/2014/02/02/configuring-emacs-for-rails.html][configuring emacs for rails]] and arrived at
   the following settings.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-mode
       :ensure t
       :config
       (setq ruby-deep-indent-paren nil))
   #+END_SRC

*** Flymake Ruby

    #+BEGIN_SRC emacs-lisp
      (use-package flymake-ruby
        :defer
        :commands (flymake-ruby-load)
        :ensure t
        :init (add-hook 'ruby-mode-hook 'flymake-ruby-load))
    #+END_SRC

*** RBenv

    #+BEGIN_SRC emacs-lisp
      (use-package rbenv
        :ensure t
        :config (global-rbenv-mode))
    #+END_SRC

*** Inf Ruby

    #+BEGIN_SRC emacs-lisp
      (use-package inf-ruby
        :commands (inf-ruby-minor-mode)
        :init
        (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode))
    #+END_SRC

*** Robe mode

    #+BEGIN_SRC emacs-lisp
      (use-package robe
        :commands (robe-mode)
        :ensure t
        :init
        (add-hook 'ruby-mode 'robe-mode)
        :config
        (eval-after-load 'company
          '(push 'company-robe company-backends)))
    #+END_SRC

** Rust

   These initial settings are copied from the [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Blang/rust/packages.el][spacemacs rust layer]].

   #+BEGIN_SRC emacs-lisp
     (use-package cargo
       :mode "\\.rs"
       :init
       (bind-keys :prefix-map cargo-mode-map
                  :prefix "C-c c"
                  ("C" . cargo-process-repeat)
                  ("." . cargo-process-repeat)
                  ("X" . cargo-run-example)
                  ("c" . cargo-process-build)
                  ("d" . cargo-process-doc)
                  ("e" . cargo-process-bench)
                  ("R" . cargo-process-current-test)
                  ("f" . cargo-process-fmt)
                  ("i" . cargo-process-init)
                  ("n" . cargo-process-new)
                  ("o" . cargo-process-current-file-tests)
                  ("s" . cargo-process-search)
                  ("u" . cargo-process-update)
                  ("x" . cargo-process-run)
                  ("t" . cargo-process-test)
                  ("R" . cargo-process-test-regexp)))

     (use-package racer
       :mode "\\.rs")

     (use-package flycheck-rust
       :mode "\\.rs"
       :init
       (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))

     (use-package ggtags
       :defer)

     (use-package html-gtags
       :ensure nil
       :defer)

     (use-package racer-mode
       :ensure racer
       :defer
       :init
       (add-hook 'racer-mode-hook #'eldoc-mode)
       (add-hook 'racer-mode-hook #'company-mode))

     (use-package company-racer
       :defer
       :init
       (with-eval-after-load 'company
         (add-to-list 'company-backends 'company-racer)))

     (use-package rust-mode
       :commands (cargo-minor-mode)
       :mode "\\.rs"
       :config
       (bind-keys :map rust-mode-map
                  ("C-c TAB" . rust-format-buffer)
                  ("TAB" . company-indent-or-complete-common))
       :init
       (setq company-tooltip-align-annotations t)
       (add-hook 'rust-mode-hook #'cargo-minor-mode)
       (add-hook 'rust-mode-hook #'racer-mode)
       (add-hook 'rust-mode-hook #'flycheck-mode)
       (add-hook 'rust-mode-hook #'electric-pair-mode))

     (use-package toml-mode
       :ensure nil
       :quelpa (toml-mode :fetcher github :repo "dryman/toml-mode.el")
       :mode "\\.toml\\'")
   #+END_SRC

** Web Mode

   For all of the webish-stuff, this mode works well. Let's enable it
   on the right things.

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :defer
       :ensure t
       :config
       (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
       (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
       (add-to-list 'auto-mode-alist '("\\.hbs\\'" . web-mode))
       (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
       (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
       (setq web-mode-engines-alist
             '(("handlebars" . "\\.hbs\\'")))
       (defun bnb/web-mode-hook ()
         (setq web-mode-markup-indent-offset 2
               web-mode-css-indent-offset 2
               web-mode-code-indent-offset 2))
       (add-hook 'web-mode-hook 'bnb/web-mode-hook))
   #+END_SRC

** HTML

   [[https://github.com/smihica/emmet-mode][Emmet mode]] allows for terse description of nested elements. There
   is great documentation on the approach at [[http://emmet.io][emmet.io]].

   #+BEGIN_SRC emacs-lisp
     (use-package emmet-mode
       :config
       (add-hook 'web-mode-hook 'emmet-mode)
       (add-hook 'sgml-mode-hook 'emmet-mode)
       (add-hook 'css-mode-hook 'emmet-mode))
   #+END_SRC

* Ivy, Counsel and Swiper

  Ivy is a completion framework somewhere between =ido= and =helm=. It
  and =counsel= are in the =swiper= package.

  #+BEGIN_SRC emacs-lisp :noweb yes
    (use-package swiper
      :bind ("H-s" . swiper)
      ("C-c S" . swiper)
      ("C-x C-r" . counsel-recentf)
      ("s-E" . counsel-colors-emacs)
      ("s-W" . counsel-colors-web)
      :config
      (setq ivy-display-style 'fancy
            ivy-use-virtual-buffers t
            ivy-re-builders-alist
            '((t . ivy--regex-fuzzy))
            colir-compose-method 'colir-compose-soft-light)
      <<smex>>
      (diminish 'ivy-mode)
      (require 'ivy-hydra)
      (ivy-mode))

    (use-package counsel
      :ensure t
      :bind
      ("M-x"     . counsel-M-x)
      ("H-y"     . counsel-yank-pop)
      ("C-x C-f" . counsel-find-file)
      ("C-c a"   . counsel-ag)
      ("C-c p s a" . counsel-projectile-ag)
      ("C-c p p" . counsel-projectile-switch-project)
      ("<f1> f"  . counsel-describe-function)
      ("<f1> v"  . counsel-describe-variable)
      ("<f1> l"  . counsel-find-library)
      ("<f2> i"  . counsel-info-lookup-symbol)
      ("<f2> u"  . counsel-unicode-char)
      :config
      (setq counsel-find-file-at-point t
            enable-recursive-minibuffers t))

    (use-package ivy-rich
      :defer
      :config
      (setq ivy-virtual-abbreviate 'full
            ivy-rich-switch-buffer-align-virtual-buffer t)
      (ivy-set-display-transformer 'ivy-switch-buffer
                                   'ivy-rich-switch-buffer-transformer))
  #+END_SRC

  The bindings introduced are replacements for built-in
  commands. =counsel-M-x= becomes my default =M-x= binding with =smex=
  ordering the results smartly.  I also enable it to try to find the
  file at point if applicable.

  The searching functionality of =C-x= advances with =swiper= showing
  search with context, navigation and matching portions.

  The remaining settings and binding relate to =ivy= itself.  This
  library does the actual listing of completion items. I bind the
  =ivy-recentf= interface to find recently used files.

  For =ivy='s look and feel, I make a few settings.  First, the
  display style is set to /fancy/.  This shows the matching portions
  of the candidates.  I also alter =colir-compose-method= to a better
  colorizing scheme for my preferred themes. Next, I instruct =ivy= to
  use virtual buffers (recentf, bookmarks) when switching buffers.
  Finally, I enable fuzzy matching of the input.

** Smex

   Counsel can use =smex= under the hood for /recent-item/
   sorting. This give a better LRU functionality to command
   selection.

   #+NAME: smex
   #+BEGIN_SRC emacs-lisp 
     (use-package smex
         :ensure t
         :config (smex-initialize))
   #+END_SRC

** Ivy View

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-view
       :ensure nil
       :bind
       ("H-[" . ivy-push-view)
       ("H-]" . ivy-pop-view)
       ("H-b" . ivy-switch-buffer)
       :config
       (setq ivy-use-virtual-buffers t))
   #+END_SRC

* IDO (Interactively Do Things)

  First, I start with some basic IDO settings. I enabled it
  everywhere so that it will work in all contexts. I like flex
  matching so I also turn that feature on. Finally, I order the file
  extensions to my liking and enable the mode.

  #+BEGIN_SRC emacs-lisp
    ;(setq ido-everywhere t)
    (setq ido-enable-flex-matching t)
    ; Do not ask to create a new buffer -- just do it.
    (setq ido-create-new-buffer 'always)
    ; Try to guess if point is at a filename
    (setq ido-use-filename-at-point 'guess)
    ; Set extension ordering
    (setq ido-file-extensions-order '(".org" ".tex" ".el" ".txt" ".c" ".cpp" ".h" ".clj"))
    ; Enable mode
    ; (ido-mode t)
  #+END_SRC

** Keystrokes

   | Keystroke | Operates on        | Description                            |
   |-----------+--------------------+----------------------------------------|
   | C-b       | Buffers            | Reverts to the old switch-buffer       |
   | C-f       | Files              | Reverts to the old find-file           |
   | C-d       | Dirs/Files         | Opens a dired buffer in current dir    |
   | C-a       | Files/Buffers      | Toggles showing ignored files          |
   | C-c       | Buffers/Dirs/Files | Toggles ignore case for names          |
   | TAB       | Buffers/Dirs/Files | Attempt to complete input              |
   | C-p       | Files              | Toggles prefix matching                |
   | C-s/C-r   | All                | Moves to next/previous match           |
   | C-t       | All                | Toggles matching Emacs Regexp          |
   | Backspace | All                | Deletes chars or up directory          |
   | C-SPC/C-@ | All                | Restricts completion list              |
   | //        | Dirs/Files         | Ignore preceding path                  |
   | ~/        | Dirs/Files         | Jump to home directory                 |
   | M-d       | Files              | Searches for input in cwd sub-dirs     |
   | C-k       | Buffers/Files      | Kills focused buffer or deletes file   |
   | M-m       | Files              | Creates a new sub-dir to cwd           |
   | M-n/M-p   | Dirs/Files         | Cycles through next/previous work dirs |
   | M-k       | Dirs/Files         | Kills active work dir from list        |
   | M-s M-s   | Dirs/Files         | Search list of work dirs for input     |

* Shells

  There are two useful shells in emacs: =eshell= and
  =ansi-term=.

** Ansi Term

   Some of the following settings were stolen from [[https://ogbe.net/emacsconfig.html]].

   These settings close =ansi-term= when I exit the shell. They also
   default to just launching =zsh= instead of asking me
   (preferred). Then it closes by setting up a hook to ensure some
   nice functionality in the terminal mode window.

   #+BEGIN_SRC emacs-lisp
     (defadvice term-sentinel (around bnb/advise-term-sentinel (proc msg))
       (if (memq (process-status proc) '(signal exit))
           (let ((buffer (process-buffer proc)))
             ad-do-it
             (kill-buffer buffer))
         ad-do-it))
     (ad-activate 'term-sentinel)

     (defadvice ansi-term (before force-zsh)
       (interactive (list "/bin/zsh")))
     (ad-activate 'ansi-term)

     (defun bnb/term-mode-hook ()
       (goto-address-mode)
       (setq-local term-buffer-maximum-size 10000))

     (add-hook 'term-mode-hook 'bnb/term-mode-hook)

     (defalias 'zsh 'ansi-term)
   #+END_SRC

** Eshell

   Built-in Eshell can provide a shell that works the same on windows or
   GNU/Linux. One of the really cool features is that you can define
   commands to use (like aliases) within the shell and have them
   directly integrate with emacs.

*** Eshell Settings

    Turn off any =$PAGER= settings inherited in the
    environment. Because this is running in Emacs, there is no need
    for a pager.

    #+BEGIN_SRC emacs-lisp
      (setenv "PAGER" "cat")
    #+END_SRC

*** Eshell Commands

    Fast fingers are used to typing =emacs= at a prompt to open a
    file.  This gives the same behavior in =eshell=.

    #+BEGIN_SRC emacs-lisp
      (defun eshell/emacs (&rest args)
        "Open a file in emacs the natural way"
        (if (null args)
            ;; If emacs is called by itself, then just go to emacs directly
            (bury-buffer)
          ;; If opening multiple files with a directory name, e.g.
          ;; > emacs bar/bar.txt foo.txt
          ;; then the names must be expanded to complete file paths.
          ;; Otherwise, find-file will look in the current directory which
          ;; would fail for 'foo.txt' in the example above.
          (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))
    #+END_SRC

    One can also keep the shell active and open files in the other
    window.

    #+BEGIN_SRC emacs-lisp
      (defun eshell/emo (&rest args)
        (mapc
           (lambda (f)
             (save-selected-window
               (find-file-other-window f)))
           (mapcar #'expand-file-name (eshell-flatten-list (reverse args)))))
    #+END_SRC

    I also setup some command aliases. Here, I create a long listing,
    =ll=, alias for =ls=, a =llc= varient with colored output, and an
    emacs shortcut.

    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load "em-alias"
        '(progn
           (eshell/alias "em" "emacs")
           (eshell/alias "ll" "ls -Aloh")
           (eshell/alias "llc" "*ls -AlohG --color=always")))
    #+END_SRC

    On a windows box, setup grep to be a cygwin version.

    #+BEGIN_SRC emacs-lisp
      (when (eq system-type 'windows-nt)
        (with-eval-after-load "eshell"
          (defun eshell/grep (&rest args)
            (eshell-grep "c:/cygwin/bin/grep.exe" args t))))
    #+END_SRC


    For Magit, there are some niceties to add.

    #+BEGIN_SRC emacs-lisp
      (defun eshell/gst (&rest args)
        (magit-status-internal (pop args) nil)
        (eshell/echo))

      (defun eshell/gd (&rest args)
        (magit-diff-unstaged)
        (eshell/echo))

      (defun eshell/gds (&rest args)
        (magit-diff-staged)
        (eshell/echo))
    #+END_SRC


*** Plan 9 Smart Shells

    See [[http://www.masteringemacs.org/article/complete-guide-mastering-eshell][the complete guide to mastering Eshell]] for more on this.
    Basically, the cursor stays on the command for editing if
    necessary.

    #+BEGIN_SRC emacs-lisp
      (require 'eshell)
      (require 'em-smart)

      (setq eshell-where-to-jump 'begin)
      (setq eshell-review-quick-commands nil)
      (setq eshell-smart-space-goes-to-end t)
      (add-hook  'eshell-mode-hook 'eshell-smart-initialize)
    #+END_SRC

* AucTeX

  [[info:AUCTeX][AUCTeX Manual]]

  Superb handling of TeX documents.

  #+BEGIN_SRC emacs-lisp
    (use-package tex-site
      :defer 10
      :ensure auctex
      :config
      (add-hook 'LaTeX-mode-hook 'flyspell-mode)
      (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
      (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
      (add-hook 'LaTeX-mode-hook 'orgtbl-mode)
      (setq TeX-auto-untabify t
            TeX-auto-save t
            TeX-save-query nil
            TeX-parse-self t
            TeX-output-view-style
            (if (eq system-type 'windows-nt)
                (quote
                 (("^pdf$" "." "SumatraPDF.exe -reuse-instance %o")
                  ("^html?$" "." "start %o")))
              (quote
               (("^pdf$" "." "evince -f %o")
                ("^html?$" "." "start %o"))))
            TeX-command-extra-options "-shell-escape"
            TeX-PDF-mode 1
            TeX-engine 'xetex)
      (setq-default TeX-master nil)
      (add-to-list 'org-latex-packages-alist
                   '("" "tikz" t))
      (setq org-latex-create-formula-image-program 'imagemagick)
      (eval-after-load "preview"
        '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
      (add-hook 'doc-view-mode-hook 'auto-revert-mode))
  #+END_SRC

** RefTeX

   [[info:RefTeX][RefTeX Manual]]

   RefTeX provides navigation, easy references, easy citations and
   integrates well into AUCTeX.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
   #+END_SRC

   | Keystroke | Function                           |
   |-----------+------------------------------------|
   | C-c =     | Show TOC and jump to sections      |
   | C-c (     | Insert a label                     |
   | C-c )     | Reference a label                  |
   | C-c [     | Insert a citation (from BibTex db) |
   | C-c <     | Index entry                        |
   | C-c >     | View index                         |
   | C-c &     | View crossref                      |

** TeX Settings

   Here are some nice features to have enabled.  Parse-self and
   auto-save will parse the file on load and save
   respectively. Untabify will remove tabs (real ones) before saving.

   I also have a default of =TeX-master= set to =nil=. I used to have
   it set to "master" as recommended in the documentation, but I had
   bad results for LaTeX files generated on the fly.

   #+BEGIN_SRC emacs-lisp
   #+END_SRC

   For viewing the output, I can specify the command to use on the
   files generated in the process. However, the programs differ on
   GNU/Linux and Windows, so I have differing settings below.

   #+BEGIN_SRC emacs-lisp
   #+END_SRC

** XeTeX settings

   To get more beautiful fonts, I use the XeTeX processor. I also
   use this in PDF mode.

   #+BEGIN_SRC emacs-lisp
   #+END_SRC

** DocView

   Have =docview= automatically revert the buffer.

* Markdown

  Everything can't be as nice as org-mode. Oh well.

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t
      :commands (markdown-mode gfm-mode)
      :mode (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'" . markdown-mode)
             ("\\.markdown\\'" . markdown-mode))
      :init (setq markdown-command "multimarkdown"))
  #+END_SRC
  
     - org-clock-goto
       Go to current/previous clocked task

     These are defined in [[Orgmode Initialization]]
* Orgmode

  The one feature I cannot do without. Let's set up some basics.

** Orgmode Initialization

   Here are the initial settings that will invoke org-mode or need to
   be set when it is loaded.

   #+BEGIN_SRC emacs-lisp
     (use-package org-mode
       :ensure org-plus-contrib
       :diminish " ⊞"
       :mode "\\.org\\(.gpg|_archive\\)?$"
       :bind
       ("C-c t"  . orgtbl-mode)
       ("C-c l"  . org-store-link)
       ("C-c r"  . org-capture)
       ("C-c b"  . org-iswitchb)
       ("<f12>"  . org-agenda)
       ("H-z"    . org-agenda)
       ("<apps>" . org-agenda)
       ("<f9> v" . visible-mode)
       ("<f9> g" . org-clock-goto)
       ("<f9> i" . org-clock-in)
       ("<f9> o" . org-clock-out)
       :config
       (bind-key "M-i" 'org-toggle-inline-images org-mode-map)
       (add-hook 'org-babel-after-execute-hook
                 (lambda () (org-display-inline-images nil t))))
   #+END_SRC

** Auto mode

   I add gpg and _archive to the list of known org files. These two
   alternative extensions are for either encrypted org files
   (=.org.gpg=) or for archives (=.org_archive=).

   This mode is set above with =use-package=.

** Hooks

   There are three hooks to consider. These are initialized in [[Orgmode
   Initialization]]. First, I add in a keystroke to toggle the inline
   images.

   The next hook just saves the org files opened before exiting
   emacs -- just in case.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'bnb/kill-emacs-hooks 'org-save-all-org-buffers 'append)
   #+END_SRC

   The final hook shows images automatically. When I execute =babel=
   to get graphs from my work logs, I hate having to toggle the inline
   images on/off again.  Here is a hook from Rick Frankel to save the
   day.

** Keys

*** Global

    Some org-mode features are so useful that I need to have them be
    available globally.

     - orgtbl-mode
       Use orgtbl in other modes
     - org-store-link
       Store a link (context-aware) to the current location
     - org-agenda
       Launch the agenda
     - org-capture
       Capture a task/note
     - org-iswitchb
       Switch org buffers
     - visible-mode
       Show the file as-is (no special org handling)
     - org-clock-in/org-clock-out
       Clock in/out of current subtree
*** Speed

    Using org-mode efficiently for task management is best done with
    speed keys. This are in effect when the cursor is on the first =*=
    of a headline. And they come with an easy cheat-sheet by typing
    =?=. I enable this feature and add some of my own commands.

    #+BEGIN_SRC emacs-lisp
      (setq org-use-speed-commands t
            org-speed-commands-user
            (quote (("0" . delete-window)
                    ("1" . delete-other-windows)
                    ("2" . split-window-vertically)
                    ("3" . split-window-horizontally)
                    ("h" . hide-other)
                    ("s" . org-save-all-org-buffers)
                    ("z" . org-add-note)
                    ("N" . org-narrow-to-subtree)
                    ("W" . widen)
                    ("m" . org-mark-subtree))))
    #+END_SRC

** Org TODO Configuration

   This is the meat of what Org can do. Keeping track of todo items
   with due dates, tags, etc. is really powerful. And I get to
   customize it to suit my needs and my workflow.

*** Keywords

    The keywords that org uses in the headlines exist as sequences
    describing the state changes. The characters in =()= also allow
    fast access to these states described [[info:org#Fast%20access%20to%20TODO%20states][here]].

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
            (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!/!)")
                (sequence "WAITING(w@/!)" "SOMEDAY(s!)" "|" "CANCELED(c@/!)")
                (sequence "OPEN(O)" "|" "CLOSED(C)"))))
    #+END_SRC

    I used to set [[elisp:(describe-variable 'org-todo-keyword-faces)][org-todo-keyword-faces]], but now I rely on theme
    settings.

*** Tags

    Org uses tags on headlines for organization. I don't currently
    use them much. I organize mainly by file with a file tag
    specified via [[info:org#In-buffer%20settings][in-buffer settings]] (=#+FILETAGS=).

    However, a global tag list provides a selection list for the
    tagging interface. I use 'project' as my tag to easily
    differentiate simple tasks from more complex ones.

    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '(("PROJECT" . ?p)))
    #+END_SRC

*** Mechanics

    The todo interface allows easy selection of states and triggers
    on certain states to store notes.

    Instead of cycling through states (and possibly triggering log
    entries), I prefer fast entry to jump right to the correct
    state. I also turn off the S-cursor transitions as state
    changes to avoid the logging prompts.

    #+BEGIN_SRC emacs-lisp
      (setq org-use-fast-todo-selection t)
      (setq org-treat-S-cursor-todo-selection-as-state-change nil)
    #+END_SRC

    Upon changing the state of todo items, I can automatically
    add/remove tags with the following list. It's a bit lispy, but
    describes what happens upon entry in the specified state. The
    state named as a string has tuples of tags and flags. 't'
    indicates to set the flag, empty means to remove it.

    #+BEGIN_SRC emacs-lisp
      (setq org-todo-state-tags-triggers
            (quote (("CANCELED"
                     ("CANCELED" . t))
                    ("WAITING"
                     ("WAITING" . t))
                    ("SOMEDAY"
                     ("SOMEDAY" . t))
                    (done
                     ("WAITING"))
                    ("TODO"
                     ("WAITING")
                     ("CANCELED"))
                    ("NEXT"
                     ("WAITING"))
                    ("DONE"
                     ("WAITING")
                     ("CANCELED")))))
    #+END_SRC

    Along with tags and states are priorities. I do not use task
    priorities myself so I turn them off.

    #+BEGIN_SRC emacs-lisp
      (setq org-enable-priority-commands nil)
    #+END_SRC

**** Logging

     Org allows logging of states. I turn this on to prompt myself
     for reasons behind specific state changes. There is also a
     setting to set a different drawer for clocking and logs.

     #+BEGIN_SRC emacs-lisp
       (setq org-log-done (quote note)
             org-log-into-drawer t
             org-drawers '("PROPERTIES" "LOGBOOK" "CLOCK"))
     #+END_SRC

**** Sub-tasks

     Naturally, some tasks are projects composed of smaller
     sub-tasks. Org allows for this as well. I like to enforce the
     dependencies of regular todo items and plain checkbox
     lists. In this way, the overall item cannot change to done
     without the completion of the sub-tasks.

     #+BEGIN_SRC emacs-lisp
       (setq org-enforce-todo-checkbox-dependencies t
             org-enforce-todo-dependencies t)
     #+END_SRC

     Because of the previous enforcement of state, I can also
     automatically infer when a parent state is complete. The
     following code marks the parent complete once the sub-tasks
     are all done.

     #+BEGIN_SRC emacs-lisp
       (defun org-summary-todo (n-done n-not-done)
         "Switch entry to DONE when all sub-entries are done, to TODO otherwise."
         (let (org-log-done org-log-states)
           (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
       (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
     #+END_SRC

** Capture

   [[info:org#Capture][Capturing]] is crucial to a task system and in this vein, org is no
   slouch. The capture templates define what get captures, where it
   goes, and what the user needs to type.

   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           '(("t" "Todo" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO %?\n  %U\n%^{Score}p" :clock-in t :clock-resume t)
             ("r" "todo (Remember location)" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO %?\n  %U\n  %a" :clock-in t :clock-resume t)
             ("n" "Note" entry
              (file "~/Documents/Org/Refile.org")
              "* %?                                                                            :NOTE:\n  %U\n  %a\n  :CLOCK:\n  :END:")
             ("i" "Isabelle Journal" entry (file+datetree "~/Documents/Personal/Org/Isabelle.org")
              "* %?\n\tEntered on %U")
             ("j" "Johannes Journal" entry (file+datetree "~/Documents/Personal/Org/Johannes.org")
              "* %?\n\tEntered on %U")
             ("a" "Andrea Journal" entry (file+datetree "~/Documents/Personal/Org/Andrea.org")
              "* %?\n\tEntered on %U")
             ("e" "Journal" entry (file+datetree "~/Documents/Personal/Org/Journal.org")
              "* %?\n\tEntered on %U")
             ("c" "Capture current TODO mix in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Burndown")
              "%(bnb/org-count-tasks-by-status)")
             ("s" "Capture Weekly Score in table" table-line (file+headline "~/Documents/Org/WeeklyReports.org" "Scores")
              "%(bnb/add-weekly-score-table-entry)")
             ("w" "Weekly Time Table" plain
              (file+function "~/Documents/Org/WeeklyReports.org" bnb/insert-weekly-clocking)
              "%(bnb/insert-weekly-time-sheet)" :unnarrowed t)
             ("o" "org-outlook" entry
              (file "~/Documents/Org/Refile.org")
              "* TODO EMAIL: %:title (%:sender)
       %c

       %?" :clock-in t :clock-resume t)))
   #+END_SRC

   There are five main capture templates here. The first two store a
   todo item in my Refile.org file. The only difference is automatic
   (contextual) link storage in the second case.

   The next item simply stores a note. The next for "Weekly Report"
   is a work in progress. I think that I'll have to either settle
   for a proper datetree or write a custom function.

   The final item is not for direct use, but through the
   =org-protocol= interface and =org-outlook= usage. This lets me
   add a link to an Outlook message on windows. I can then get an
   email at work, mark it to store in emacs and quickly get back to
   the message later.

*** Capture-template helpers for data tables

    These helpers provide functionality used in the capture templates
    above.

    Modified from [[http://sachachua.com/blog/2014/05/getting-r-ggplot2-work-emacs-org-mode-babel-blocks-also-tracking-number-todos/][Sacha Chua]], this code get the current mix of tasks
    in the agenda files. I use this as part of my weekly review for
    task amount and mix at a glance.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/org-count-tasks-by-status ()
        (interactive)
        (let ((counts (make-hash-table :test 'equal))
              (today (format-time-string "%Y-%m-%d" (current-time)))
              values output)
          (org-map-entries
           (lambda ()
             (let ((status (elt (org-heading-components) 2)))
               (when status
                 (puthash status (1+ (or (gethash status counts) 0)) counts))))
           "-HOME"
           'agenda)
          (setq values (mapcar (lambda (x)
                                 (or (gethash x counts) 0))
                               '("DONE" "STARTED" "TODO" "WAITING" "CANCELLED" "SOMEDAY")))
          (setq output
                (concat "| " today " | "
                        (mapconcat 'number-to-string values " | ")
                        " | "
                        (number-to-string (apply '+ values))
                        " | "
                        (number-to-string
                         (round (/ (* 100.0 (car values)) (apply '+ values))))
                        "% |"))
          (if (called-interactively-p 'any)
              (insert output)
            output)))
    #+END_SRC

    I also have a helper function to get the score of done tasks
    closed within the last week.  I store this in a table line with
    year and workweek number.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/add-weekly-score-table-entry ()
        (let ((score (apply
                       '+
                       (org-map-entries
                        (lambda ()
                          (string-to-number (or (org-entry-get (point) "Score") "0")))
                        "/DONE"
                        'agenda)))
               (year (format-time-string "%Y" (current-time)))
               (ww (number-to-string (bnb/workweek))))
          (format "| %s | %s | %s |" year ww score)))
    #+END_SRC

** Refile

   [[info:org#Refiling%20notes][Refiling notes]] is also spectacular with Org. That is what makes
   it possible for me to simply put every captured item into
   Refile.org and worry about organization later.

   For my setup, I use separate files that hold a singular Tasks
   headline. Because of that, I turn on caching first.

   For the refile targets, I will allow up to 2 levels of search for
   filing in any of the agenda files. For refiling within the current
   file, I set the max to five levels. Anything deeper than six
   levels will exhaust the depth of my thought.

   Finally, I set the filenames to be first for refiling.

   #+BEGIN_SRC emacs-lisp
     (setq org-refile-use-cache t
           org-refile-targets '((org-agenda-files :maxlevel . 2)
                                (nil :maxlevel . 5))
           org-refile-use-outline-path 'file)
   #+END_SRC

** Agenda

   Once I have captured and refiled my tasks, I need to remember to
   do them and see what is on the agenda. The ways to view the tasks
   at hand are nicely programmable.

   Some basic settings control small tidbits in the agenda. I turn
   on tags in the agenda line, show the logged items for the day,
   and only show a time grid if a scheduled tasks exists.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-show-inherited-tags t
        org-agenda-log-mode-items '(clock)
        org-agenda-clockreport-parameter-plist '(:link nil :maxlevel 2 :fileskip0 t)
        org-agenda-time-grid '((daily today require-timed)
                               "----------------"
                               (800 1000 1200 1400 1600 1800 2000)))
#+END_SRC

*** Views

    The key to knowing what work there is the agenda views. These
    provide a landscape to list, filter or manipulate
    tasks. =org-agenda-custom-commands= defines which views are
    available by default.

    First, I define a little helper function (from Sacha Chua) to
    display a note with agenda.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/org-agenda-with-tip (arg)
        (org-agenda-list arg)
        (let ((inhibit-read-only t)
              (pos (point)))
          (goto-char (point-max))
          (goto-char pos)))
    #+END_SRC

    WIP from: https://github.com/fniessen/emacs-leuven/blob/master/org-custom-agenda-views.el

    #+BEGIN_SRC emacs-lisp
      ;; Reset everything to nil
      (setq org-agenda-custom-commands nil)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("a" "Agenda" bnb/org-agenda-with-tip))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("c" . "COLLECT...") t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("cb" "CollectBox"
                     ((alltodo ""))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("f" . "FOCUS...") t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   `("f." "Today"
                     ((agenda ""
                              ((org-agenda-entry-types '(:timestamp :sexp))
                               (org-agenda-overriding-header
                                (concat "CALENDAR Today"
                                        (format-time-string "%a %d" (current-time))))
                               (org-agenda-span 'day)))
                      (tags-todo "LEVEL=1+REFILE"
                                 ((org-agenda-overriding-header "COLLECTBOX (Unscheduled)")))
                      (tags-todo "DEADLINE=\"<+0d>\""
                                 ((org-agenda-overriding-header "DUE TODAY")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notedeadline))
                                  (org-agenda-sorting-strategy '(priority-down))))
                      (tags-todo "DEADLINE<\"<+0d>\""
                                 ((org-agenda-overriding-header "OVERDUE")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notedeadline))
                                  (org-agenda-sorting-strategy '(priority-down))))
                      (agenda ""
                              ((org-agenda-entry-types '(:scheduled))
                               (org-agenda-overriding-header "SCHEDULED")
                               (org-agenda-skip-function
                                '(org-agenda-skip-entry-if 'todo 'done))
                               (org-agenda-sorting-strategy
                                '(priority-down time-down))
                               (org-agenda-span 'day)
                               (org-agenda-start-on-weekday nil)
                               (org-agenda-time-grid nil)))
                      (todo "DONE"
                            ((org-agenda-overriding-header "COMPLETED"))))
                     ((org-agenda-format-date "")
                      (org-agenda-start-with-clockreport-mode nil))) t)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("fh" "Hotlist"
                     ((tags-todo "DEADLINE<\"<+0d>\""
                                 ((org-agenda-overriding-header "OVERDUE")))
                      (tags-todo "DEADLINE>=\"<+0d>\"+DEADLINE<=\"<+1w>\""
                                 ((org-agenda-overriding-header "DUE IN NEXT 7 DAYS")))
                      (tags-todo "DEADLINE=\"\"+FLAGGED|DEADLINE>\"<+1w>\"+FLAGGED"
                                 ((org-agenda-overriding-header "FLAGGED"))))
                     ((org-agenda-todo-ignore-scheduled 'future)))  t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("r" . "REVIEW...") t)

      (add-to-list 'org-agenda-custom-commands
                   '("ra" . "All Tasks...") t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("rad" "All Tasks (grouped by Due Date)"
                     ((tags-todo "DEADLINE<\"<+0d>\""
                                 ((org-agenda-overriding-header "OVERDUE")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline))))
                      (tags-todo "DEADLINE=\"<+0d>\""
                                 ((org-agenda-overriding-header "DUE TODAY")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline))))
                      (tags-todo "DEADLINE=\"<+1d>\""
                                 ((org-agenda-overriding-header "DUE TOMORROW")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline))))
                      (tags-todo "DEADLINE>\"<+1d>\"+DEADLINE<=\"<+7d>\""
                                 ((org-agenda-overriding-header "DUE WITHIN A WEEK")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline))))
                      (tags-todo "DEADLINE>\"<+7d>\"+DEADLINE<=\"<+28d>\""
                                 ((org-agenda-overriding-header "DUE WITHIN A MONTH")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline))))
                      (tags-todo "DEADLINE>\"<+28d>\""
                                 ((org-agenda-overriding-header "DUE LATER")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'notdeadline)))                           )
                      (tags-todo "TODO={WAIT}"
                                 ((org-agenda-overriding-header "WAITING FOR")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'deadline))))
                      (todo ""
                                 ((org-agenda-overriding-header "WAITING FOR")
                                  (org-agenda-skip-function
                                   '(org-agenda-skip-entry-if 'deadline)))))
                     ((org-agenda-sorting-strategy '(priority-down))
                      (org-agenda-write-buffer-name "All Tasks (grouped by Due Date)"))
                       "~/Documents/Org/all-tasks-by-due-date.pdf") t)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("ra1" "All Tasks with a due date"
                     ((alltodo ""))
                     ((org-agenda-overriding-header "All Tasks (sorted by Due Date)")
                      (org-agenda-skip-function
                       '(org-agenda-skip-entry-if 'notdeadline))
                      (org-agenda-sorting-strategy '(deadline-up)))) t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("rt" . "Timesheet...") t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
       ;; Show what happened today.
      (add-to-list 'org-agenda-custom-commands
                   '("rtd" "Daily Timesheet"
                     ((agenda ""))
                     ((org-agenda-log-mode-items '(clock closed))
                      (org-agenda-overriding-header "DAILY TIMESHEET")
                      (org-agenda-show-log 'clockcheck)
                      (org-agenda-span 'day)
                      (org-agenda-start-with-clockreport-mode t)
                      (org-agenda-time-grid nil))) t)

      ;; Show what happened this week.
      (add-to-list 'org-agenda-custom-commands
                   '("rtw" "Weekly Timesheet"
                     ((agenda ""))
                     (
                      ;; (org-agenda-format-date "")
                      (org-agenda-overriding-header "WEEKLY TIMESHEET")
                      (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp))
                      (org-agenda-span 'week)
                      (org-agenda-start-on-weekday 1)
                      (org-agenda-start-with-clockreport-mode t)
                      (org-agenda-time-grid nil))) t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("rc" . "Calendar...") t)

      (add-to-list 'org-agenda-custom-commands
                   '("rc7" "Events and appointments for 7 days"
                     ((agenda ""))
                     ((org-agenda-entry-types '(:timestamp :sexp))
                      ;; (org-agenda-overriding-header "Calendar for 7 days")
                      ;; (org-agenda-repeating-timestamp-show-all t)
                      (org-agenda-span 'week)
                      (org-agenda-format-date "\n%a %d")
                      ;; (org-agenda-date-weekend ... new face ...)
                      (org-agenda-time-grid nil))) t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-agenda-custom-commands
                   '("rw" "Weekly review"
                     ((tags "CATEGORY={@REFILE}&LEVEL<=2"
                            ((org-agenda-overriding-header "NEW TASKS")))
                      (agenda ""
                              ((org-agenda-clockreport-mode t)
                               (org-agenda-format-date
                                (concat "\n"
                                        "%Y-%m-%d" " %a "
                                        (make-string (window-width) ?_)))
                               (org-agenda-overriding-header "PAST WEEK")
                               (org-agenda-prefix-format " %?-11t %i %-12:c% s")
                               (org-agenda-show-log 'clockcheck)
                               (org-agenda-span 7)
                               (org-agenda-start-day "-1w")
                               (org-deadline-warning-days 0)))
                      (agenda ""
                              ((org-agenda-overriding-header "NEXT MONTH")
                               (org-agenda-span 'month)
                               (org-agenda-start-day "+0d")
                               (org-deadline-warning-days 0)))
                      (todo "PROJECT"
                            ((org-agenda-overriding-header "PROJECT LIST")))
                      (todo "DONE|PROJECTDONE"
                            ((org-agenda-overriding-header
                              "Candidates to be archived")))))
       )
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; (setq org-agenda-custom-commands
      ;;       '(
      ;;         ("w" "Tasks waiting on something" tags "WAITING/!"
      ;;          ((org-use-tag-inheritance nil)
      ;;           (org-agenda-todo-ignore-scheduled nil)
      ;;           (org-agenda-todo-ignore-deadlines nil)
      ;;           (org-agenda-todo-ignore-with-date nil)
      ;;           (org-agenda-overriding-header "Waiting Tasks")))
      ;;         ("r" "Refile New Notes and Tasks" tags "LEVEL=1+REFILE"
      ;;          ((org-agenda-todo-ignore-with-date nil)
      ;;           (org-agenda-todo-ignore-deadlines nil)
      ;;           (org-agenda-todo-ignore-scheduled nil)
      ;;           (org-agenda-overriding-header "Tasks to Refile")))
      ;;         ("n" "Next" tags-todo "-WAITING-CANCELED/!NEXT"
      ;;          ((org-agenda-overriding-header "Next Tasks")))
      ;;         ("A" "Tasks to be Archived" tags "LEVEL=2-REFILE/DONE|CANCELED"
      ;;          ((org-agenda-overriding-header "Tasks to Archive")))
      ;;         ("u" "Upcoming tasks" tags "+SCHEDULED<=\"<+1w>\"-TODO=\"DONE\"|+DEADLINE<=\"<+1w>\"-TODO=\"DONE\""
      ;;          ((org-agenda-overriding-header "Upcoming tasks")))
      ;;         ("U" "Unscheduled tasks" todo "TODO"
      ;;          ((org-agenda-overriding-header "Unscheduled Tasks")
      ;;           (org-agenda-skip-function
      ;;            (lambda nil
      ;;              (org-agenda-skip-entry-if (quote scheduled) (quote deadline))))))
      ;;         ("P" "Printable Agenda" ;tags-todo "-DONE-CANCELED-SOMEDAY"
      ;;          ((tags-todo "+IGNORE"
      ;;                      ((org-agenda-overriding-header "\n== Upcoming Items ==\n")))
      ;;           (agenda "" ((org-agenda-span 14)
      ;;                       (org-agenda-start-on-weekday nil)
      ;;                       (org-agenda-prefix-format "[ ] %T:\t")
      ;;                       (org-agenda-repeating-timestamp-show-all t)
      ;;                       (org-deadline-warning-days 7)))
      ;;           (tags-todo "-DRB-SOMEDAY-REFERENCE-BNBECKWITH"
      ;;                      ((org-agenda-prefix-format "[ ] %T:\t")
      ;;                       (org-agenda-sorting-strategy '(tag-up priority-down))
      ;;                       (org-agenda-todo-keyword-format "")
      ;;                       (org-agenda-todo-ignore-with-date nil)
      ;;                       (org-agenda-todo-ignore-scheduled nil)
      ;;                       (org-agenda-todo-ignore-deadlines nil)
      ;;                       (org-agenda-overriding-header "\nTasks by Context\n------------------\n"))))
      ;;          ((ps-number-of-columns 2)
      ;;           (ps-landscape-mode t)
      ;;           (org-agenda-with-colors nil)
      ;;           (org-agenda-compact-blocks t)
      ;;           (org-agenda-remove-tags t)
      ;;           (ps-paper-type 'a4))
      ;;          ("~/TODO.pdf" "~/TODO.ps"))
      ;;         ("l" "Scoreless" tags-todo "+Score<1"
      ;;          ((org-agenda-todo-ignore-with-date nil)
      ;;           (org-agenda-todo-ignore-scheduled nil)
      ;;           (org-agenda-todo-ignore-deadlines nil)
      ;;           (org-agenda-overriding-header "Scoreless Tasks")))
      ;;         ("h" "Habits" tags "STYLE=\"habit\""
      ;;          ((org-agenda-todo-ignore-with-date nil)
      ;;           (org-agenda-todo-ignore-scheduled nil)
      ;;           (org-agenda-todo-ignore-deadlines nil)
      ;;           (org-agenda-overriding-header "Habits")))
      ;;         ("#" "Stuck Projects" tags-todo "LEVEL=2-REFILE+PROJECT|LEVEL=1+REFILE/!-DONE-CANCELED"
      ;;          ((org-agenda-skip-function 'bh/skip-non-stuck-projects)
      ;;           (org-agenda-overriding-header "Stuck Projects")))
      ;;         ("z" "Agenda (including Personal Files)" agenda ""
      ;;          ((org-agenda-files (list "~/Documents/Personal/Org/"))))
      ;;         ("c" "Select default clocking task" tags "LEVEL=2-REFILE"
      ;;          ((org-agenda-skip-function
      ;;            '(org-agenda-skip-subtree-if 'notregexp "^\\*\\* Organization"))
      ;;           (org-agenda-overriding-header "Set default clocking task with C-u C-u I")))))
    #+END_SRC

    Phew! That is a lot of lisp! It is easiest to describe each view
    by the key that triggers it.

     - =a= Agenda with tip (keystroke tip)
     - =w= Tasks waiting on something
     - =r= Refile New notes and tasks
     - =n= Next
       Any task with the NEXT tag
     - =A= Tasks ready for Archive
     - =u= Upcoming tasks
       Scheduled or due in the next week.
     - =U= Unscheduled tasks
     - =P= Printable agenda
       Formats tasks at the top with upcoming items below.
     - =S= Scoreless tasks
       Use this to get the scoreless tasks and edit in column mode
     - =h= Habits
     - =#= Stuck projects
     - =z= Agenda with Personal Files
     - =c= Select default clocking task

** Export

   Here are some global export settings make sense for HTML and \LaTeX.

*** HTML

   For HTML, I just want to inline the links to images.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-html-inline-images t)
   #+END_SRC

   I also used to suppress the postamble with
   =org-export-html-postamble=.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-postamble nil)
   #+END_SRC

   I'll use the /fancy/ HTML5 export by default.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-doctype "html5"
           org-html-html5-fancy t)
   #+END_SRC

   I like to have striped tables in email, but this is terribly
   difficult due to cruddy CSS support. Luckily,
   =org-html-table-row-tags= saves the day and assigns the right
   classes to the table rows. Now styling can be done in CSS-reduced
   instances.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-table-row-tags
           (cons '(cond (top-row-p "<tr class=\"tr-top\">")
                        (bottom-row-p "<tr class=\"tr-bottom\">")
                        (t (if (= (mod row-number 2) 1)
                               "<tr class=\"tr-odd\">"
                             "<tr class=\"tr-even\">")))
                 "</tr>"))
   #+END_SRC

*** LaTeX

   For \LaTeX, I want to convert fragments to images, and use minted
   for any source blocks. I also want to have =xelatex= as the
   backend.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-latex-listings 'minted
           org-export-latex-custom-lang-environments
           '((emacs-lisp "common-lispcode"))
           org-export-latex-minted-options '()
           org-latex-to-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   #+END_SRC


   Also, I want to enable some of the other contributed
   exporters. To do this, simply require the files necessary that
   are not on by default.

   I add exporters for github-flavored markdown and tufte html.

   #+BEGIN_SRC emacs-lisp
     (use-package ox-gfm)
     (use-package ox-tufte)
   #+END_SRC

*** EPUB

    E-readers may be a thing that sticks around.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-epub :after org-mode)
    #+END_SRC

** Clocking

   I have found clocking to be useful in understanding where my time
   goes. And Org makes this easy, fast and painless to do. So very
   nice.

   The clock has some general settings around persistence (resuming
   clocks), history length and resuming a task after clocking in
   twice (interrupted task).

   #+BEGIN_SRC emacs-lisp
     (org-clock-persistence-insinuate)
     (setq org-clock-history-length 28
           org-clock-in-resume t)
   #+END_SRC

   Behavior of the clock can change to accommodate other needs. I
   like having clocks log into a specific drawer. Also, it is nice
   to remove zero-time clocks and clock out automatically when an
   item completes.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-into-drawer "CLOCK"
           org-clock-out-remove-zero-time-clocks t
           org-clock-out-when-done t)
   #+END_SRC

   Two settings help resolve most clock issues that I have
   seen. Persisting the clock across sessions helps prevent loss of
   time by accident. Auto-resolution of open clocks help prompt how
   to handle the situation where a dangling clock exists.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-persist 'history
           org-clock-auto-clock-resolution 'when-no-clock-is-running)
   #+END_SRC

   Two final settings regarding clocking setup how I change and view
   the clocks. I want any clock reports to include the currently
   clocked task as well. And for clock editing, I change to 15
   minute increments.

   #+BEGIN_SRC emacs-lisp
     (setq org-clock-report-include-clocking-task t
           org-time-stamp-rounding-minutes '(1 15))
   #+END_SRC

** Modules

   Org-modules allow for specific functionality within org-mode.

   #+BEGIN_SRC emacs-lisp
     (setq org-modules
           '(org-bbdb
             org-bibtex
             org-crypt
             org-gnus
             org-id
             org-info
             org-jsinfo
             org-habit
             org-inlinetask
             org-irc
             org-plot
             org-protocol
             org-bookmark
             org-calc))
   #+END_SRC

*** Habit

    Some tasks repeat, but you still want to log when you have done
    it. I use this to help me always do my weekly or yearly
    reviews. By including it in =org-modules=, habits get activated.

    My one setting blow sets a width for the graph in Agenda View.

    #+BEGIN_SRC emacs-lisp
      (setq org-habit-graph-column 50)
    #+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((calc       . t)
     (clojure    . t)
     (C          . t)
     (ditaa      . t)
     (dot        . t)
     (emacs-lisp . t)
     (gnuplot    . t)
     (latex      . t)
     (perl       . t)
     (plantuml   . t)
     (python     . t)
     (shell      . t)
     (sqlite     . t)))
#+END_SRC

*** Extra Babel Packages

#+BEGIN_SRC emacs-lisp
  (use-package ob-http :after org-mode)
#+END_SRC

** Miscellaneous Settings
*** Columns

    The default columns are as follows.

    #+BEGIN_SRC emacs-lisp
      (setq org-columns-default-format
            "%80ITEM(Task) %5Score{+} %10Effort(Effort){:} %10CLOCKSUM")
    #+END_SRC

*** Automatically save org files

    I like to save early and often. In earlier versions of orgmode, I
    sometimes had the capture buffer/timer crash on me. So, now I
    save at the top of every hour to be sure.

    #+BEGIN_SRC emacs-lisp
      (run-at-time "00:59" 3600 'org-save-all-org-buffers)
    #+END_SRC

*** File Applications

    This list lets org know how to handle the links of given file
    types. Most things open inside =emacs=, but the others
    set to default rely on the OS to supply a program.

    #+BEGIN_SRC emacs-lisp
      (setq org-file-apps
            '((auto-mode . emacs)
                ("\\.x?html?\\'" . default)
                ("\\.pdf\\'" . default)
                ("\\.mm\\'" . default)))
    #+END_SRC

*** Goto Interface

    By using =C-c C-j=, you can jump easily around a large orgfile
    such as this one. Naturally, the interface you use to do so is
    customizable.

    I explicitly set it to the default because I sometimes go back
    and forth with the default and =outline-path-completion= setting.

    #+BEGIN_SRC emacs-lisp
      (setq org-goto-interface 'outline-path)
    #+END_SRC

*** Special Control Keys

    Orgmode has a different idea of some of the default emacs
    commands to make it easier to work with the structures involved.

    For =C-a= or =C-e= within a headline, it will only try to
    navigate the headline text the first time. Additional keypresses
    will move to the true beginning/ending of lines.

    =C-k= also can behave specially in headlines depending on its
    location. When point is at the beginning, it will kill the
    headline and the folded subtree below. In the middle of a
    headline, it kills the headline text up to the tags. After the
    headline text, it kills the tags.

    #+BEGIN_SRC emacs-lisp
      (setq org-special-ctrl-a/e t
            org-special-ctrl-k t)
    #+END_SRC

*** Auto-revert mode

    If the org files are under DVCS like git, then the edits may
    happen while open in emacs.

    This is a global setting, but most useful for the org files that
    exists elsewhere.

    #+BEGIN_SRC emacs-lisp
      (setq global-auto-revert-mode t)
      (diminish 'auto-revert-mode " 🔁")
    #+END_SRC

*** IDO Integration

    IDO integrates well into orgmode. Anytime completion is
    necessary, I like to use the IDO mechanics.

    The =outline-path-completion= may conflict with IDO, so then it
    is best to have it not use IDO in this case.

    #+BEGIN_SRC emacs-lisp
      (setq org-completion-use-ido t
            org-outline-path-complete-in-steps nil)
    #+END_SRC

*** Display settings

    There are a collection of settings that define how the
    headlines, subtrees, and notes render.

    For the headline stars, there are two settings of note. I am
    explicit that I do *not* want only odd levels. I also like to
    hide the leading stars.

    #+BEGIN_SRC emacs-lisp
      (setq org-odd-levels-only nil
            org-hide-leading-stars nil)
    #+END_SRC

    Cycling the headline states can produce different views of the
    files. I like this to be as compact as possible, so I try to
    squash the lines between the collapsed trees. There is also a
    flag to open a file collapsed. This I like too -- I get a
    compact view of the file and can jump to a relevant section with
    =C-c C-j=.

    #+BEGIN_SRC emacs-lisp
      (setq org-cycle-separator-lines 0
            org-startup-folded 'content)
    #+END_SRC

    When using SRC-blocks, org can provide highlighting native to
    the SRC type. Note that this may slow down some files.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
    #+END_SRC

*** Insertion

     I define when org should leave a blank line before an
     item. In my case, it is headings and plain list items.

    #+BEGIN_SRC emacs-lisp
      (setq org-blank-before-new-entry '((heading)
                                         (plain-list-item)))
    #+END_SRC

     Also, when inserting a new heading, do so after the current
     subtree.

    #+BEGIN_SRC emacs-lisp
      (setq org-insert-heading-respect-content t)
    #+END_SRC

*** Properties

    #+BEGIN_SRC emacs-lisp
      (setq org-global-properties
            '(("STYLE_ALL"  . "habit")
              ("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00")
              ("Score_ALL"  . "1 2 3 5 8")))
    #+END_SRC

*** Calendar

    [[http://acidwords.com/posts/2017-02-16-displaying-org-mode-appointments-in-calendar.html][Acidwords.com]] outlined a nice way to highlight days in the
    calendar.  These settings are a result of that work.

    #+BEGIN_SRC emacs-lisp
      (setq calendar-mark-diary-entries-flag t)
    #+END_SRC

*** Teleport

    From [[http://kitchingroup.cheme.cmu.edu/blog/2016/03/18/Org-teleport-headlines/][the Kitchin Group]], I can have a nice /teleport/ function for
    org sections. Using a speed command on the current headline kills
    it and then presents avy-style markers to select the insertion
    point.

    By default the teleported headline will be inserted after the
    target. With a prefix argument, it will preceed the target.

    #+BEGIN_SRC emacs-lisp
      (defun bnb/org-teleport (&optional arg)
        "Teleport the current heading to after a headline selected with avy.
      With a prefix ARG move the headline to before the selected
      headline. With a numeric prefix, set the headline level. If ARG
      is positive, move after, and if negative, move before."
        (interactive "P")
        ;; Kill current headline
        (org-mark-subtree)
        (kill-region (region-beginning) (region-end))
        ;; Jump to a visible headline
        (avy-with avy-goto-line (avy--generic-jump "^\\*+" nil avy-style))
        (cond
         ;; Move before  and change headline level
         ((and (numberp arg) (> 0 arg))
          (save-excursion
            (yank))
          ;; arg is what we want, second is what we have
          ;; if n is positive, we need to demote (increase level)
          (let ((n (- (abs arg) (car (org-heading-components)))))
            (cl-loop for i from 1 to (abs n)
                     do
                     (if (> 0 n)
                         (org-promote-subtree)
                       (org-demote-subtree)))))
         ;; Move after and change level
         ((and (numberp arg) (< 0 arg))
          (org-mark-subtree)
          (goto-char (region-end))
          (when (eobp) (insert "\n"))
          (save-excursion
            (yank))
          ;; n is what we want and second is what we have
          ;; if n is positive, we need to demote
          (let ((n (- (abs arg) (car (org-heading-components)))))
            (cl-loop for i from 1 to (abs n)
                     do
                     (if (> 0 n) (org-promote-subtree)
                       (org-demote-subtree)))))

         ;; move to before selection
         ((equal arg '(4))
          (save-excursion
            (yank)))
         ;; move to after selection
         (t
          (org-mark-subtree)
          (goto-char (region-end))
          (when (eobp) (insert "\n"))
          (save-excursion
            (yank))))
        (outline-hide-leaves))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-speed-commands-user
                   (cons "k" (lambda ()
                               (org-mark-subtree)
                               (kill-region
                                (region-beginning)
                                (region-end)))))

      (add-to-list 'org-speed-commands-user
                   (cons "q" (lambda ()
                               (avy-with avy-goto-line
                                 (avy--generic-jump "^\\*+" nil avy-style)))))

      (add-to-list 'org-speed-commands-user
                   (cons "T" 'bnb/org-teleport))
    #+END_SRC
    
*** Protocols
**** Org-mac-protocol

**** Org-board                                                      :PENDING:

     Bookmarking in org.

     #+BEGIN_SRC emacs-lisp
       (use-package org-board
         :config (global-set-key (kbd "C-c o") org-board-keymap)
         (setq org-board-capture-file "~/Documents/Personal/Org/bookmarks.org")
         (add-to-list 'org-capture-templates
                      `("w" "catpure through org protocol" entry
                        (file+headline ,org-board-capture-file "Unsorted")
                        "* %?:description\n:PROPERTIES:\n:URL: %:link\n:END:\n\n Added %U")))
     #+END_SRC

** Org Repo Todo                                                    :PENDING:

   Make it easy to setup a =TODO.org= from within a repo. I use this
   to capture thoughts while coding

   #+BEGIN_SRC emacs-lisp
     (use-package org-repo-todo
       :ensure t
       :bind ("s-;" . ort/capture-todo)
       ("s-'" . ort/capture-checkitem)
       ("s-`" . ort/goto-todos))
   #+END_SRC

** Org projectile                                                   :PENDING:

   Make it easy to capture tasks into the right projects and setup a project todo.

   #+BEGIN_SRC emacs-lisp
     (use-package org-projectile
       :bind ("C-c n p" . org-projectile:project-todo-completing-read)
       :ensure t
       :config
       (org-projectile:per-repo)
       (add-to-list 'org-capture-templates
                    (org-projectile:project-todo-entry))
       (setq org-agenda-files
             (append org-agenda-files (org-projectile:todo-files))
             org-projectile:per-repo-filename "Tasks.org"))
   #+END_SRC

* Calc

  Working in computer land, I add these additional units to =calc=.

  #+BEGIN_SRC emacs-lisp
    (use-package calc
      :commands (calc)
      :init
      (setq math-additional-units
          '((GiB "1024 * MiB" "Giga Byte")
            (MiB "1024 * KiB" "Mega Byte")
            (KiB "1024 * B"   "Kilo Byte")
            (B   nil          "Byte")
            (Gib "1024 * Mib" "Giga bit")
            (Mib "1024 * Kib" "Mega bit")
            (Kib "1024 * b"   "Kilo bit")
            (b   nil          "bit")
            )))
  #+END_SRC

* Server

   [[info:emacs#Emacs%20Server][Using Emacs as a server]] is a great way to keep the power
   responsive.

  #+BEGIN_SRC emacs-lisp
    (when (and (or (eq system-type 'windows-nt) (eq system-type 'darwin)) 
               (not (and (boundp 'server-clients) server-clients))
               (not (daemonp)))
      (server-start))
  #+END_SRC

   I need to look into the TCP connections to see how
   that work across machines. Perhaps it can be useful in a
   multi-machine work environment.

* Local customizations (custom.el)

   I typically use the customize interface to generate any local
   settings such as proxies, paths, fonts, etc. that may vary from
   machine to machine.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file "~/.emacs.d/custom.el")
    (load-file custom-file)
  #+END_SRC

* Local customizations (user-login-name)

  I also intend to have a generic call to an installed local file
  that may need to behave differently from =custom.el=. This loads
  last so that it can modify any existing setting made here to work
  on the specific system in question.

  In the code below, I add =~/.emacs.d/= to the load path and have a
  protected call to =load-library=.  If the file exists, it gets
  loaded, otherwise the error normally returned if the file is
  non-existent gets ignored.

  #+BEGIN_SRC emacs-lisp
    (condition-case err
        (progn
          (load-file (format "~/.emacs.d/%s.el"  user-login-name))
          (message "Loaded local settings file %s.el" user-login-name))
      (file-error
       (message "Skipping %s library as it does not exist." user-login-name))
      nil)
  #+END_SRC




